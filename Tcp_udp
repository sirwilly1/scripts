Sure, I'll modify the function to take a string input instead of using the `ProtocolType` enumeration. Here's the updated code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/select.h>

#define BUF_SIZE 1024

void redirect(const char *protocol, const char *target_ip, int listen_port, int send_port) {
    int listen_fd, send_fd;
    struct sockaddr_in listen_addr, send_addr, target_addr;
    char buffer[BUF_SIZE];
    int is_udp = strcmp(protocol, "udp") == 0;
    
    // Create socket for listening
    if (is_udp)
        listen_fd = socket(AF_INET, SOCK_DGRAM, 0);
    else
        listen_fd = socket(AF_INET, SOCK_STREAM, 0);
        
    if (listen_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // Bind the socket
    memset(&listen_addr, 0, sizeof(listen_addr));
    listen_addr.sin_family = AF_INET;
    listen_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    listen_addr.sin_port = htons(listen_port);
    if (bind(listen_fd, (struct sockaddr *)&listen_addr, sizeof(listen_addr)) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    // Create socket for sending
    if (is_udp)
        send_fd = socket(AF_INET, SOCK_DGRAM, 0);
    else
        send_fd = socket(AF_INET, SOCK_STREAM, 0);
        
    if (send_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // Set up target address
    memset(&target_addr, 0, sizeof(target_addr));
    target_addr.sin_family = AF_INET;
    target_addr.sin_addr.s_addr = inet_addr(target_ip);
    target_addr.sin_port = htons(send_port);

    fd_set read_fds;
    int max_fd = (listen_fd > send_fd) ? listen_fd : send_fd;

    while (1) {
        FD_ZERO(&read_fds);
        FD_SET(listen_fd, &read_fds);

        // Wait for activity on the listening socket
        if (select(max_fd + 1, &read_fds, NULL, NULL, NULL) == -1) {
            perror("select");
            exit(EXIT_FAILURE);
        }

        if (FD_ISSET(listen_fd, &read_fds)) {
            if (is_udp) {
                // Receive data from the client
                struct sockaddr_in client_addr;
                socklen_t addr_len = sizeof(client_addr);
                ssize_t recv_len = recvfrom(listen_fd, buffer, BUF_SIZE, 0, (struct sockaddr *)&client_addr, &addr_len);
                if (recv_len == -1) {
                    perror("recvfrom");
                    exit(EXIT_FAILURE);
                }

                // Send data to the target server
                if (sendto(send_fd, buffer, recv_len, 0, (struct sockaddr *)&target_addr, sizeof(target_addr)) == -1) {
                    perror("sendto");
                    exit(EXIT_FAILURE);
                }
            } else {
                // Accept incoming connection
                socklen_t addr_len = sizeof(target_addr);
                int client_fd = accept(listen_fd, (struct sockaddr *)&target_addr, &addr_len);
                if (client_fd == -1) {
                    perror("accept");
                    exit(EXIT_FAILURE);
                }

                // Forward data between client and target server
                ssize_t recv_len;
                while ((recv_len = recv(client_fd, buffer, BUF_SIZE, 0)) > 0) {
                    if (send(send_fd, buffer, recv_len, 0) == -1) {
                        perror("send");
                        exit(EXIT_FAILURE);
                    }
                    // Receive response from target server
                    recv_len = recv(send_fd, buffer, BUF_SIZE, 0);
                    if (recv_len == -1) {
                        perror("recv");
                        exit(EXIT_FAILURE);
                    }
                    // Forward response to client
                    if (send(client_fd, buffer, recv_len, 0) == -1) {
                        perror("send");
                        exit(EXIT_FAILURE);
                    }
                }

                if (recv_len == -1) {
                    perror("recv");
                    exit(EXIT_FAILURE);
                }

                // Close client socket
                close(client_fd);
            }
        }
    }

    // Close sockets
    close(listen_fd);
    close(send_fd);
}

int main() {
    // Example usage for UDP
    redirect("udp", "target_ip", listen_port, send_port);

    // Example usage for TCP
    // redirect("tcp", "target_ip", listen_port, send_port);
    
    return 0;
}
```

Now, you can call the `redirect()` function with either `"udp"` or `"tcp"` as the first argument to specify the protocol. The function will then set up the appropriate socket types and behave accordingly.

--------

Certainly! We can simplify the code by using `send()` for both UDP and TCP. Here's the modified code:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/select.h>

#define BUF_SIZE 1024

void redirect(const char *protocol, const char *target_ip, int listen_port, int send_port) {
    int listen_fd, send_fd;
    struct sockaddr_in listen_addr, send_addr, target_addr;
    char buffer[BUF_SIZE];
    int is_udp = strcmp(protocol, "udp") == 0;
    
    // Create socket for listening
    listen_fd = (is_udp) ? socket(AF_INET, SOCK_DGRAM, 0) : socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // Bind the socket
    memset(&listen_addr, 0, sizeof(listen_addr));
    listen_addr.sin_family = AF_INET;
    listen_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    listen_addr.sin_port = htons(listen_port);
    if (bind(listen_fd, (struct sockaddr *)&listen_addr, sizeof(listen_addr)) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    // Create socket for sending
    send_fd = (is_udp) ? socket(AF_INET, SOCK_DGRAM, 0) : socket(AF_INET, SOCK_STREAM, 0);
    if (send_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // Set up target address
    memset(&target_addr, 0, sizeof(target_addr));
    target_addr.sin_family = AF_INET;
    target_addr.sin_addr.s_addr = inet_addr(target_ip);
    target_addr.sin_port = htons(send_port);

    fd_set read_fds;
    int max_fd = (listen_fd > send_fd) ? listen_fd : send_fd;

    while (1) {
        FD_ZERO(&read_fds);
        FD_SET(listen_fd, &read_fds);

        // Wait for activity on the listening socket
        if (select(max_fd + 1, &read_fds, NULL, NULL, NULL) == -1) {
            perror("select");
            exit(EXIT_FAILURE);
        }

        if (FD_ISSET(listen_fd, &read_fds)) {
            if (is_udp) {
                // Receive data from the client
                struct sockaddr_in client_addr;
                socklen_t addr_len = sizeof(client_addr);
                ssize_t recv_len = recvfrom(listen_fd, buffer, BUF_SIZE, 0, (struct sockaddr *)&client_addr, &addr_len);
                if (recv_len == -1) {
                    perror("recvfrom");
                    exit(EXIT_FAILURE);
                }

                // Send data to the target server
                if (send(send_fd, buffer, recv_len, 0) == -1) {
                    perror("send");
                    exit(EXIT_FAILURE);
                }
            } else {
                // Accept incoming connection
                socklen_t addr_len = sizeof(target_addr);
                int client_fd = accept(listen_fd, (struct sockaddr *)&target_addr, &addr_len);
                if (client_fd == -1) {
                    perror("accept");
                    exit(EXIT_FAILURE);
                }

                // Forward data between client and target server
                ssize_t recv_len;
                while ((recv_len = recv(client_fd, buffer, BUF_SIZE, 0)) > 0) {
                    if (send(send_fd, buffer, recv_len, 0) == -1) {
                        perror("send");
                        exit(EXIT_FAILURE);
                    }
                    // Receive response from target server
                    recv_len = recv(send_fd, buffer, BUF_SIZE, 0);
                    if (recv_len == -1) {
                        perror("recv");
                        exit(EXIT_FAILURE);
                    }
                    // Forward response to client
                    if (send(client_fd, buffer, recv_len, 0) == -1) {
                        perror("send");
                        exit(EXIT_FAILURE);
                    }
                }

                if (recv_len == -1) {
                    perror("recv");
                    exit(EXIT_FAILURE);
                }

                // Close client socket
                close(client_fd);
            }
        }
    }

    // Close sockets
    close(listen_fd);
    close(send_fd);
}

int main() {
    // Example usage for UDP
    redirect("udp", "target_ip", listen_port, send_port);

    // Example usage for TCP
    // redirect("tcp", "target_ip", listen_port, send_port);
    
    return 0;
}
```

In this modified version, `send()` is used for both UDP and TCP transmissions. This simplifies the code by removing the need for separate logic based on the protocol.


----------


Yes, it's possible to use `recv()` for both UDP and TCP. However, for UDP, `recvfrom()` is typically used because it allows you to retrieve the sender's address. 

Here's the modified code using `recv()` for both UDP and TCP:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/select.h>

#define BUF_SIZE 1024

void redirect(const char *protocol, const char *target_ip, int listen_port, int send_port) {
    int listen_fd, send_fd;
    struct sockaddr_in listen_addr, send_addr, target_addr;
    char buffer[BUF_SIZE];
    int is_udp = strcmp(protocol, "udp") == 0;
    
    // Create socket for listening
    listen_fd = (is_udp) ? socket(AF_INET, SOCK_DGRAM, 0) : socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // Bind the socket
    memset(&listen_addr, 0, sizeof(listen_addr));
    listen_addr.sin_family = AF_INET;
    listen_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    listen_addr.sin_port = htons(listen_port);
    if (bind(listen_fd, (struct sockaddr *)&listen_addr, sizeof(listen_addr)) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    // Create socket for sending
    send_fd = (is_udp) ? socket(AF_INET, SOCK_DGRAM, 0) : socket(AF_INET, SOCK_STREAM, 0);
    if (send_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // Set up target address
    memset(&target_addr, 0, sizeof(target_addr));
    target_addr.sin_family = AF_INET;
    target_addr.sin_addr.s_addr = inet_addr(target_ip);
    target_addr.sin_port = htons(send_port);

    fd_set read_fds;
    int max_fd = (listen_fd > send_fd) ? listen_fd : send_fd;

    while (1) {
        FD_ZERO(&read_fds);
        FD_SET(listen_fd, &read_fds);

        // Wait for activity on the listening socket
        if (select(max_fd + 1, &read_fds, NULL, NULL, NULL) == -1) {
            perror("select");
            exit(EXIT_FAILURE);
        }

        if (FD_ISSET(listen_fd, &read_fds)) {
            if (is_udp) {
                // Receive data
                ssize_t recv_len = recv(listen_fd, buffer, BUF_SIZE, 0);
                if (recv_len == -1) {
                    perror("recv");
                    exit(EXIT_FAILURE);
                }

                // Send data to the target server
                if (sendto(send_fd, buffer, recv_len, 0, (struct sockaddr *)&target_addr, sizeof(target_addr)) == -1) {
                    perror("sendto");
                    exit(EXIT_FAILURE);
                }
            } else {
                // Accept incoming connection
                socklen_t addr_len = sizeof(target_addr);
                int client_fd = accept(listen_fd, (struct sockaddr *)&target_addr, &addr_len);
                if (client_fd == -1) {
                    perror("accept");
                    exit(EXIT_FAILURE);
                }

                // Forward data between client and target server
                ssize_t recv_len;
                while ((recv_len = recv(client_fd, buffer, BUF_SIZE, 0)) > 0) {
                    if (send(send_fd, buffer, recv_len, 0) == -1) {
                        perror("send");
                        exit(EXIT_FAILURE);
                    }
                    // Receive response from target server
                    recv_len = recv(send_fd, buffer, BUF_SIZE, 0);
                    if (recv_len == -1) {
                        perror("recv");
                        exit(EXIT_FAILURE);
                    }
                    // Forward response to client
                    if (send(client_fd, buffer, recv_len, 0) == -1) {
                        perror("send");
                        exit(EXIT_FAILURE);
                    }
                }

                if (recv_len == -1) {
                    perror("recv");
                    exit(EXIT_FAILURE);
                }

                // Close client socket
                close(client_fd);
            }
        }
    }

    // Close sockets
    close(listen_fd);
    close(send_fd);
}

int main() {
    // Example usage for UDP
    redirect("udp", "target_ip", listen_port, send_port);

    // Example usage for TCP
    // redirect("tcp", "target_ip", listen_port, send_port);
    
    return 0;
}
```

In this modified version, `recv()` is used for both UDP and TCP. For UDP, the sender's address is not retrieved directly, but since the target address is known, it can be used for sending the response back. For TCP, the sender's address is not relevant as it's a connection-oriented protocol.
