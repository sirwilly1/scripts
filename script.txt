#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <netdb.h>

#define BUFFER_SIZE 4096

// Structure to hold redirection arguments
struct RedirectionArgs {
    int local_port;
    char remote_ip[16];
    int remote_port;
    int duration;
    int is_tcp;
};

// Function to handle errors and exit with a message
void error_exit(const char *message) {
    perror(message);
    exit(1);
}

// Function to create a socket of a specified protocol and socket type
int create_socket(int protocol, int sock_type) {
    int sockfd = socket(AF_INET, sock_type, protocol);
    if (sockfd < 0) error_exit("socket creation failed");
    return sockfd;
}

// Function to create and connect a socket, given a host, port, and socket type
int create_and_connect(char *host, int port, int sock_type) {
    struct addrinfo hints, *res;
    int sockfd;
    char port_str[6];

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = sock_type;

    sprintf(port_str, "%d", port);
    if (getaddrinfo(host, port_str, &hints, &res) != 0)
        error_exit("getaddrinfo failed");

    sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (sockfd < 0)
        error_exit("socket creation failed");

    if (connect(sockfd, res->ai_addr, res->ai_addrlen) < 0)
        error_exit("connect failed");

    freeaddrinfo(res);
    return sockfd;
}

// Function to forward data from the source socket to the destination socket
void forward(int src_sock, int dest_sock) {
    char buffer[BUFFER_SIZE];
    int len = recv(src_sock, buffer, BUFFER_SIZE, 0);
    if (len > 0) {
        send(dest_sock, buffer, len, 0);
    }
}

// Function to run TCP redirection
void run_tcp_redirection(struct RedirectionArgs *args) {
    int local_sock = create_socket(0, SOCK_STREAM);
    int remote_sock = create_and_connect(args->remote_ip, args->remote_port, SOCK_STREAM);

    // If TCP, listen for incoming connections
    listen(local_sock, 5);
    struct sockaddr_in client_addr;
    socklen_t addr_len = sizeof(client_addr);
    int new_local_sock = accept(local_sock, (struct sockaddr*)&client_addr, &addr_len);
    if (new_local_sock < 0)
        error_exit("accept failed");
    close(local_sock);
    local_sock = new_local_sock;

    struct timeval timeout;
    timeout.tv_sec = args->duration;
    timeout.tv_usec = 0;

    fd_set readfds;

    while (1) {
        FD_ZERO(&readfds);
        FD_SET(local_sock, &readfds);
        FD_SET(remote_sock, &readfds);

        int activity = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);
        if (activity < 0) error_exit("select error");
        if (activity == 0) break;

        if (FD_ISSET(local_sock, &readfds)) {
            forward(local_sock, remote_sock);
        }

        if (FD_ISSET(remote_sock, &readfds)) {
            forward(remote_sock, local_sock);
        }
    }

    close(local_sock);
    close(remote_sock);
}

// Function to run UDP redirection
void run_udp_redirection(struct RedirectionArgs *args) {
    int local_sock = create_socket(0, SOCK_DGRAM);
    int remote_sock = create_and_connect(args->remote_ip, args->remote_port, SOCK_DGRAM);

    struct timeval timeout;
    timeout.tv_sec = args->duration;
    timeout.tv_usec = 0;

    fd_set readfds;

    while (1) {
        FD_ZERO(&readfds);
        FD_SET(local_sock, &readfds);
        FD_SET(remote_sock, &readfds);

        int activity = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);
        if (activity < 0) error_exit("select error");
        if (activity == 0) break;

        if (FD_ISSET(local_sock, &readfds)) {
            forward(local_sock, remote_sock);
        }

        if (FD_ISSET(remote_sock, &readfds)) {
            forward(remote_sock, local_sock);
        }
    }

    close(local_sock);
    close(remote_sock);
}

// Function to run redirection based on the specified protocol
void run_redirection(struct RedirectionArgs *args) {
    if (args->is_tcp) {
        run_tcp_redirection(args);
    } else {
        run_udp_redirection(args);
    }
}

int main(int argc, char *argv[]) {
    int opt;
    struct RedirectionArgs args;
    int set_flags = 0; // Bit flags to ensure all needed args are set

    // Parse command-line arguments using getopt
    while ((opt = getopt(argc, argv, "p:l:r:d:t:")) != -1) {
        switch (opt) {
            case 'p': // Protocol
                args.is_tcp = strcmp(optarg, "tcp") == 0 ? 1 : 0;
                set_flags |= 1 << 0;
                break;
            case 'l': // Local port
                args.local_port = atoi(optarg);
                set_flags |= 1 << 1;
                break;
            case 'r': // Remote IP:port
                sscanf(optarg, "%15[^:]:%d", args.remote_ip, &args.remote_port);
                set_flags |= 1 << 2;
                break;
            case 'd': // Duration
                args.duration = atoi(optarg);
                set_flags |= 1 << 3;
                break;
            case 't': // Total number of redirections (will loop the same settings)
                int total = atoi(optarg);
                for (int i = 0; i < total; ++i) {
                    if (set_flags == (1 << 4) - 1) {
                        run_redirection(&args);
                    } else {
                        fprintf(stderr, "Missing or invalid arguments\n");
                        exit(1);
                    }
                }
                return 0;
            default:
                fprintf(stderr, "Usage: %s -p <protocol> -l <local_port> -r <remote_ip:port> -d <duration> -t <total_redirections>\n", argv[0]);
                exit(1);
        }
    }

    if (set_flags == (1 << 4) - 1) {
        run_redirection(&args);
    } else {
        fprintf(stderr, "Missing or invalid arguments\n");
        exit(1);
    }

    return 0;
}
//useage ./program_name -p tcp -l 8080 -r 192.168.1.10:9090 -d 10



/////////////////////


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void redirectTCP(const char *source_ip, int source_port, const char *dest_ip, int dest_port) {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    char buffer[1024] = {0};

    // Creating socket file descriptor
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = inet_addr(source_ip);
    address.sin_port = htons(source_port);

    // Binding the socket to the address
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    // Put the server socket in passive mode
    if (listen(server_fd, 3) < 0) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
        perror("accept");
        exit(EXIT_FAILURE);
    }

    // Read data from the incoming connection
    int valread = read(new_socket, buffer, 1024);

    // Create a new socket for forwarding the TCP packet
    int sock = 0;
    struct sockaddr_in serv_addr;
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        printf("\n Socket creation error \n");
        return;
    }

    memset(&serv_addr, '0', sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(dest_port);

    // Convert IPv4 and IPv6 addresses from text to binary form
    if(inet_pton(AF_INET, dest_ip, &serv_addr.sin_addr)<=0) {
        printf("\nInvalid address/ Address not supported \n");
        return;
    }

    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        printf("\nConnection Failed \n");
        return;
    }

    send(sock, buffer, valread, 0);
    printf("TCP packet redirected\n");

    close(new_socket);
    close(sock);
}

### UDP Packet Redirection

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void redirectUDP(const char *source_ip, int source_port, const char *dest_ip, int dest_port) {
    int sockfd;
    char buffer[1024];
    struct sockaddr_in servaddr, cliaddr;

    // Creating socket file descriptor
    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    memset(&servaddr, 0, sizeof(servaddr));
    memset(&cliaddr, 0, sizeof(cliaddr));

    // Filling server information
    servaddr.sin_family = AF_INET; // IPv4
    servaddr.sin_addr.s_addr = inet_addr(source_ip);
    servaddr.sin_port = htons(source_port);

    // Bind the socket with the server address
    if (bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    int len, n;
    len = sizeof(cliaddr);  //len is value/result
    n = recvfrom(sockfd, (char *)buffer, 1024, MSG_WAITALL, (struct sockaddr *) &cliaddr, &len);
    buffer[n] = '\0';

    // Create a new socket for forwarding the UDP packet
    int new_sock;
    if ((new_sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("socket creation failed");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in dest_addr;
    dest_addr.sin_family = AF_INET;
    dest_addr.sin_port = htons(dest_port);
    dest_addr.sin_addr.s_addr = inet_addr(dest_ip);

    sendto(new_sock, buffer, n, MSG_CONFIRM, (const struct sockaddr *) &dest_addr, sizeof(dest_addr));
    printf("UDP packet redirected\n");

    close(sockfd);
    close(new_sock);
}

int main() {
    // Example usage
    redirectTCP("127.0.0.1", 8080, "127.0.0.1", 9090);
    redirectUDP("127.0.0.1", 8081, "127.0.0.1", 9091);
    return 0;
}


//////////////////

Compilation:

First, you need to compile the C code. Save the provided code into a file, let's say redirect.c. Then, compile the code using gcc:

Copy code
gcc redirect.c -o redirect
This will generate an executable named redirect.

Run the Program:

Execute the compiled binary with the appropriate permissions:

bash
Copy code
sudo ./redirect
We're using sudo here because binding to ports below 1024 requires superuser privileges. If you're binding to ports above 1024, you might not need sudo.

Testing:

To test the program:

For TCP redirection:
Start a TCP server on port 9090 to which our program redirects the packets. You can use netcat for this:

yaml
Copy code
nc -l 9090
Now, in another terminal, send data to the address 127.0.0.1 on port 8080:

bash
Copy code
echo "Hello, TCP!" | nc 127.0.0.1 8080
You should see "Hello, TCP!" printed in the terminal where the netcat server is running.

For UDP redirection:
Start a UDP server on port 9091:

yaml
Copy code
nc -lu 9091
Now, in another terminal, send data using UDP:

bash
Copy code
echo "Hello, UDP!" | nc -u 127.0.0.1 8081
You should see "Hello, UDP!" printed in the terminal where the netcat server is running.

Remember, this is a basic example for demonstration purposes. In a real-world scenario, you would need to consider error handling, handling multiple connections, and security implications. The provided program simply receives a packet and forwards it without handling any subsequent communication. If you want to develop a full-fledged proxy, you would need to introduce more complexity and features.




///////////

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE 4096

// Structure to hold all the required redirection parameters
struct RedirectionArgs {
    char sending_ip[16];
    int sending_port;
    char redirection_ip[16];
    int redirection_port;
    char recv_ip[16];
    int recv_port;
};

// Error handling function
void error_exit(const char *message) {
    perror(message);
    exit(1);
}

// Create a socket and connect/bind based on the provided parameters
int create_and_connect(char *host, int port, int is_server, int is_udp) {
    struct sockaddr_in addr;
    int sockfd;

    // Create a UDP or TCP socket based on the is_udp flag
    if (is_udp) {
        sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    } else {
        sockfd = socket(AF_INET, SOCK_STREAM, 0);
    }

    if (sockfd < 0)
        error_exit("socket creation failed");

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);

    // If it's a server socket, bind it. Otherwise, connect it.
    if (is_server) {
        addr.sin_addr.s_addr = INADDR_ANY;
        if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
            error_exit("bind failed");
    } else {
        inet_pton(AF_INET, host, &addr.sin_addr);
        if (is_udp) {
            return sockfd;
        } else {
            if (connect(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
                error_exit("connect failed");
        }
    }

    return sockfd;
}

// Function to handle UDP redirection
void handle_udp_redirection(struct RedirectionArgs *args) {
    struct sockaddr_in sending_addr, recv_addr;
    char buffer[BUFFER_SIZE];
    int redirection_sock, n;
    socklen_t addr_len;

    // Create a UDP socket for redirection
    redirection_sock = create_and_connect(NULL, args->redirection_port, 1, 1);

    // Set up recv server address
    memset(&recv_addr, 0, sizeof(recv_addr));
    recv_addr.sin_family = AF_INET;
    recv_addr.sin_port = htons(args->recv_port);
    inet_pton(AF_INET, args->recv_ip, &recv_addr.sin_addr);

    // Infinite loop to keep listening and redirecting the UDP packets
    while (1) {
        addr_len = sizeof(sending_addr);
        n = recvfrom(redirection_sock, buffer, BUFFER_SIZE, 0, (struct sockaddr *)&sending_addr, &addr_len);
        if (n <= 0) break;

        sendto(redirection_sock, buffer, n, 0, (struct sockaddr *)&recv_addr, sizeof(recv_addr));
    }

    close(redirection_sock);
}

// Function to handle TCP redirection
void handle_tcp_redirection(struct RedirectionArgs *args) {
    struct sockaddr_in sending_addr, redirection_addr, recv_addr;
    char buffer[BUFFER_SIZE];
    int redirection_sock, n;
    socklen_t addr_len;

    // Create a TCP socket for redirection and listen
    redirection_sock = create_and_connect(NULL, args->redirection_port, 1, 0);
    if (listen(redirection_sock, 5) < 0)
        error_exit("listen failed");

    // Accept the incoming connection
    struct sockaddr_in client_addr;
    addr_len = sizeof(client_addr);
    int accept_sock = accept(redirection_sock, (struct sockaddr *)&client_addr, &addr_len);
    if (accept_sock < 0)
        error_exit("accept failed");

    // Set up recv server address
    memset(&recv_addr, 0, sizeof(recv_addr));
    recv_addr.sin_family = AF_INET;
    recv_addr.sin_port = htons(args->recv_port);
    inet_pton(AF_INET, args->recv_ip, &recv_addr.sin_addr);

    // Infinite loop to keep listening and redirecting the TCP packets
    while (1) {
        n = recv(accept_sock, buffer, BUFFER_SIZE, 0);
        if (n <= 0) break;

        sendto(accept_sock, buffer, n, 0, (struct sockaddr *)&recv_addr, sizeof(recv_addr));
    }

    close(accept_sock);
    close(redirection_sock);
}

int main(int argc, char *argv[]) {
    struct RedirectionArgs args;
    int opt;
    char protocol[4] = "TCP";  // Default protocol

    // Parse command line arguments
    while ((opt = getopt(argc, argv, "s:S:r:R:c:C:p:")) != -1) {
        switch (opt) {
            case 's':
                strncpy(args.sending_ip, optarg, sizeof(args.sending_ip));
                break;
            case 'S':
                args.sending_port = atoi(optarg);
                break;
            case 'r':
                strncpy(args.redirection_ip, optarg, sizeof(args.redirection_ip));
                break;
            case 'R':
                args.redirection_port = atoi(optarg);
                break;
            case 'c':
                strncpy(args.recv_ip, optarg, sizeof(args.recv_ip));
                break;
            case 'C':
                args.recv_port = atoi(optarg);
                break;
            case 'p':
                strncpy(protocol, optarg, sizeof(protocol));
                break;
            default:
                fprintf(stderr, "Usage: %s -s <sending_ip> -S <sending_port> -r <redirection_ip> -R <redirection_port> -c <recv_ip> -C <recv_port> -p <protocol (TCP/UDP)>\n", argv[0]);
                exit(1);
        }
    }

    // Check for required parameters and choose TCP or UDP redirection
    if (args.sending_port && args.redirection_port && args.recv_port &&
        strlen(args.sending_ip) && strlen(args.redirection_ip) && strlen(args.recv_ip)) {
        if (strcmp(protocol, "TCP") == 0) {
            handle_tcp_redirection(&args);
        } else if (strcmp(protocol, "UDP") == 0) {
            handle_udp_redirection(&args);
        } else {
            fprintf(stderr, "Unsupported protocol. Use TCP or UDP.\n");
            exit(1);
        }
    } else {
        fprintf(stderr, "Invalid or missing arguments.\n");
        exit(1);
    }

    return 0;
}



///////////////////////////////////


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <netdb.h>
#include <sys/select.h>

#define BUFFER_SIZE 4096

struct RedirectionArgs {
    char sending_ip[16];
    int sending_port;
    char redirection_ip[16];
    int redirection_port;
    char recv_ip[16];
    int recv_port;
    int is_tcp;
    int duration;
};

int create_and_bind(const char *ip, int port, int type) {
    struct sockaddr_in addr;
    int sock = socket(AF_INET, type, 0);
    if (sock < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    inet_pton(AF_INET, ip, &addr.sin_addr);
    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        perror("bind");
        close(sock);
        exit(EXIT_FAILURE);
    }
    return sock;
}

int create_and_connect(const char *ip, int port, int type) {
    struct sockaddr_in addr;
    int sock = socket(AF_INET, type, 0);
    if (sock < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    inet_pton(AF_INET, ip, &addr.sin_addr);
    if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
        perror("connect");
        close(sock);
        exit(EXIT_FAILURE);
    }
    return sock;
}

void forward(int from_sock, int to_sock) {
    char buffer[BUFFER_SIZE];
    ssize_t bytes_received = recv(from_sock, buffer, sizeof(buffer), 0);
    if (bytes_received <= 0) {
        close(from_sock);
        close(to_sock);
        exit(EXIT_SUCCESS);
    }
    send(to_sock, buffer, bytes_received, 0);
}

void forward_packets_tcp(struct RedirectionArgs *args) {
    int send_sock = create_and_bind(args->sending_ip, args->sending_port, SOCK_STREAM);
    listen(send_sock, 5);
    int client_sock = accept(send_sock, NULL, NULL);
    int recv_sock = create_and_connect(args->recv_ip, args->recv_port, SOCK_STREAM);

    fd_set read_fds;
    struct timeval timeout;
    timeout.tv_sec = args->duration;
    timeout.tv_usec = 0;

    while (1) {
        FD_ZERO(&read_fds);
        FD_SET(client_sock, &read_fds);
        FD_SET(recv_sock, &read_fds);

        int activity = select(FD_SETSIZE, &read_fds, NULL, NULL, &timeout);

        if (activity <= 0) {
            break;
        }

        if (FD_ISSET(client_sock, &read_fds)) {
            forward(client_sock, recv_sock);
        }
        if (FD_ISSET(recv_sock, &read_fds)) {
            forward(recv_sock, client_sock);
        }
    }
    close(client_sock);
    close(send_sock);
    close(recv_sock);
}

void forward_packets_udp(struct RedirectionArgs *args) {
    int send_sock = create_and_bind(args->sending_ip, args->sending_port, SOCK_DGRAM);
    int recv_sock = create_and_connect(args->redirection_ip, args->redirection_port, SOCK_DGRAM);

    fd_set read_fds;
    struct timeval timeout;
    timeout.tv_sec = args->duration;
    timeout.tv_usec = 0;

    while (1) {
        FD_ZERO(&read_fds);
        FD_SET(send_sock, &read_fds);
        FD_SET(recv_sock, &read_fds);

        int activity = select(FD_SETSIZE, &read_fds, NULL, NULL, &timeout);

        if (activity <= 0) {
            break;
        }

        if (FD_ISSET(send_sock, &read_fds)) {
            forward(send_sock, recv_sock);
        }
        if (FD_ISSET(recv_sock, &read_fds)) {
            forward(recv_sock, send_sock);
        }
    }
    close(send_sock);
    close(recv_sock);
}

int main(int argc, char *argv[]) {
    if (argc != 9) {
        fprintf(stderr, "Usage: %s <Sending_IP> <Sending_Port> <Redirection_IP> <Redirection_Port> <Recv_IP> <Recv_Port> <tcp|udp> <Duration>\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    struct RedirectionArgs args;
    strcpy(args.sending_ip, argv[1]);
    args.sending_port = atoi(argv[2]);
    strcpy(args.redirection_ip, argv[3]);
    args.redirection_port = atoi(argv[4]);
    strcpy(args.recv_ip, argv[5]);
    args.recv_port = atoi(argv[6]);
    args.is_tcp = strcmp(argv[7], "tcp") == 0;
    args.duration = atoi(argv[8]);

    if (args.is_tcp) {
        forward_packets_tcp(&args);
    } else {
        forward_packets_udp(&args);
    }
    return 0;
}
/// ./packet_redirection 192.168.1.10 22 192.168.1.20 2222 192.168.1.30 22 tcp 3600


////


To test the packet redirection program, you'll need access to three network-connected machines or three different network interfaces on the same machine for the basic use case. You can use VMs, cloud servers, or physical machines. Below, I'll describe how you can set up a basic test scenario with SSH traffic redirection:

Assuming you have three networked machines:

1. **Machine A**: This will be the client that initiates an SSH connection.
2. **Machine B**: This will be the machine that runs the packet redirection program to intercept and redirect SSH traffic.
3. **Machine C**: This will be the SSH server to which the redirected SSH traffic is forwarded.

Here are the steps to set up and test the program:

1. **Compilation**:
   Compile the packet redirection program on Machine B using the `gcc` compiler.

2. **Execution**:
   On Machine B, run the packet redirection program with the appropriate arguments. For example:
   ```bash
   ./packet_redirection <Machine_B_IP> <Machine_B_Port> <Machine_C_IP> 22 <Machine_A_IP> 22 tcp <Duration>
   ```

   - `<Machine_B_IP>` is the IP address of Machine B.
   - `<Machine_B_Port>` is a port number that the program will listen on Machine B.
   - `<Machine_C_IP>` is the IP address of Machine C (the SSH server).
   - `<Machine_A_IP>` is the IP address of Machine A (the client).
   - `<Duration>` is the duration for which the program will run.

3. **SSH Configuration**:
   On Machine A, use SSH to connect to Machine B. For example:
   ```bash
   ssh -p <Machine_B_Port> <Machine_B_IP>
   ```

   You will connect to Machine B, but the packet redirection program on Machine B will redirect your SSH traffic to Machine C, acting as a middleman.

4. **Testing SSH Connection**:
   You should be able to establish an SSH connection to Machine B. Any SSH traffic you send to Machine B will be forwarded to Machine C, and you'll interact with the SSH server on Machine C. This setup allows you to test the redirection of SSH traffic.

5. **Stopping the Program**:
   To stop the packet redirection program, you can use the keyboard shortcut `Ctrl + C` on Machine B.

Keep in mind that this is a simplified test scenario. In real-world use cases, you should consider additional factors, such as security, network configurations, and permissions. Always ensure you have proper authorization and comply with legal and ethical standards when working with network traffic interception and redirection.

///////send test code 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <Send_IP> <Send_Port>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    const char *send_ip = argv[1];
    int send_port = atoi(argv[2);

    int send_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (send_sock < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in send_addr;
    send_addr.sin_family = AF_INET;
    send_addr.sin_port = htons(send_port);
    inet_pton(AF_INET, send_ip, &send_addr.sin_addr);

    if (connect(send_sock, (struct sockaddr *)&send_addr, sizeof(send_addr)) < 0) {
        perror("connect");
        close(send_sock);
        exit(EXIT_FAILURE);
    }

    char message[] = "This is a test message from the send server.";
    send(send_sock, message, sizeof(message), 0);

    close(send_sock);
    return 0;
}


//////recv test code 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>

#define BUFFER_SIZE 4096

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <Receive_Port>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int recv_port = atoi(argv[1);

    int recv_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (recv_sock < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in recv_addr;
    recv_addr.sin_family = AF_INET;
    recv_addr.sin_port = htons(recv_port);
    recv_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(recv_sock, (struct sockaddr *)&recv_addr, sizeof(recv_addr)) < 0) {
        perror("bind");
        close(recv_sock);
        exit(EXIT_FAILURE);
    }

    listen(recv_sock, 1);

    int client_sock = accept(recv_sock, NULL, NULL);

    char buffer[BUFFER_SIZE];
    ssize_t bytes_received = recv(client_sock, buffer, sizeof(buffer), 0);

    if (bytes_received > 0) {
        printf("Received data from the send server:\n");
        write(STDOUT_FILENO, buffer, bytes_received);
        printf("\n");
    }

    close(client_sock);
    close(recv_sock);

    return 0;
}







To use the provided packet redirection program:

1. **Compilation**: Before you can run the program, you need to compile it. Open a terminal and navigate to the directory containing the source code. Compile the code using the `gcc` compiler (or another C compiler of your choice):

   ```bash
   gcc -o packet_redirection packet_redirection.c
   ```

   This will create an executable named `packet_redirection`.

2. **Usage**: You can run the program with the following syntax:

   ```bash
   ./packet_redirection <Sending_IP> <Sending_Port> <Redirection_IP> <Redirection_Port> <Recv_IP> <Recv_Port> <tcp|udp> <Duration>
   ```

   Replace the placeholders with appropriate values:

   - `<Sending_IP>`: The IP address the program will listen on for incoming packets.
   - `<Sending_Port>`: The port number the program will listen on for incoming packets.
   - `<Redirection_IP>`: The IP address of the redirection server.
   - `<Redirection_Port>`: The port number of the redirection server.
   - `<Recv_IP>`: The IP address of the final receiving server.
   - `<Recv_Port>`: The port number of the final receiving server.
   - `<tcp|udp>`: Specify `tcp` for TCP traffic (e.g., SSH) or `udp` for UDP traffic.
   - `<Duration>`: The duration (in seconds) for which the program should run before exiting.

3. **Examples**:

   - Redirecting SSH traffic:
     ```bash
     ./packet_redirection 192.168.1.10 22 192.168.1.20 2222 192.168.1.30 22 tcp 3600
     ```
     This command will listen for SSH connections on IP `192.168.1.10` port `22`, redirect them through `192.168.1.20` on port `2222`, and finally forward them to `192.168.1.30` on port `22`. The program will do this for 1 hour (3600 seconds).

   - Redirecting UDP traffic:
     ```bash
     ./packet_redirection 192.168.1.10 5000 192.168.1.20 5001 192.168.1.30 5002 udp 300
     ```
     This command will listen for UDP packets on IP `192.168.1.10` port `5000`, redirect them through `192.168.1.20` on port `5001`, and finally forward them to `192.168.1.30` on port `5002`. The program will do this for 5 minutes (300 seconds).

4. **Stopping the Program**: If you wish to stop the program before the specified duration, you can use the keyboard shortcut `Ctrl + C`.

Always remember to use such tools ethically and responsibly. Unauthorized redirection or interception of network traffic can be illegal and unethical. Ensure you have proper permissions and are in compliance with local regulations and laws.






#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <netdb.h>
#include <sys/select.h>
#include <stdbool.h>

#define BUFFER_SIZE 4096

struct RedirectionArgs {
    char sending_ip[16];
    int sending_port;
    char redirection_ip[16];
    int redirection_port;
    char recv_ip[16];
    int recv_port;
    int is_tcp;
    int duration;
};

int create_and_bind(const char *ip, int port, int type) {
    // Implementation for create_and_bind function (same as before)
}

int create_and_connect(const char *ip, int port, int type) {
    // Implementation for create_and_connect function (same as before)
}

void forward(int from_sock, int to_sock) {
    // Implementation for forward function (same as before)
}

void forward_packets_tcp(struct RedirectionArgs *args) {
    // Implementation for forward_packets_tcp function (same as before)
}

void forward_packets_udp(struct RedirectionArgs *args) {
    // Implementation for forward_packets_udp function (same as before)
}

int parse_config_line(const char *line, struct RedirectionArgs *args) {
    // Parse the line and fill in the args structure
    // Example parsing code (you can modify as needed):
    int result = sscanf(line, "%15s %d %15s %d %15s %d %4s %d",
        args->sending_ip, &args->sending_port,
        args->redirection_ip, &args->redirection_port,
        args->recv_ip, &args->recv_port,
        args->protocol, &args->duration);

    // Check if parsing was successful
    if (result == 8) {
        return 1; // Successful parsing
    } else {
        fprintf(stderr, "Invalid configuration line: %s", line);
        return 0; // Parsing failed
    }
}


int main(int argc, char *argv[]) {
    if (argc == 2) {
        // Check if a configuration file is provided
        const char *config_file_path = argv[1];
        FILE *config_file = fopen(config_file_path, "r");

        if (config_file) {
            // Configuration file exists, read and execute configurations
            char line[1024];
            while (fgets(line, sizeof(line), config_file)) {
                struct RedirectionArgs args;
                if (parse_config_line(line, &args)) {
                    if (args.is_tcp) {
                        forward_packets_tcp(&args);
                    } else {
                        forward_packets_udp(&args);
                    }
                }
            }
            fclose(config_file);
        } else {
            fprintf(stderr, "Error: Could not open the specified configuration file.\n");
            exit(EXIT_FAILURE);
        }
    } else if (argc == 9) {
        // No configuration file, use command-line arguments for a single redirection
        struct RedirectionArgs args;
        strcpy(args.sending_ip, argv[1]);
        args.sending_port = atoi(argv[2]);
        strcpy(args.redirection_ip, argv[3]);
        args.redirection_port = atoi(argv[4]);
        strcpy(args.recv_ip, argv[5]);
        args.recv_port = atoi(argv[6]);
        args.is_tcp = strcmp(argv[7], "tcp") == 0;
        args.duration = atoi(argv[8]);

        if (args.is_tcp) {
            forward_packets_tcp(&args);
        } else {
            forward_packets_udp(&args);
        }
    } else {
        fprintf(stderr, "Usage: %s <Config_File> OR %s <Sending_IP> <Sending_Port> <Redirection_IP> <Redirection_Port> <Recv_IP> <Recv_Port> <tcp|udp> <Duration>\n", argv[0], argv[0]);
        exit(EXIT_FAILURE);
    }

    return 0;
}


To use the updated `packet_redirection` program that supports reading redirection configurations from a `.config` file or running a single redirection based on command-line arguments, follow these usage instructions:

**Running Multiple Redirections from a Configuration File:**

1. Create a configuration file (e.g., `redirections.config`) that contains one redirection configuration per line. Each line should specify the parameters for a single redirection.

   Example `redirections.config`:
   ```
   192.168.1.10 22 192.168.1.20 2222 192.168.1.30 22 tcp 3600
   192.168.1.11 5000 192.168.1.21 5001 192.168.1.31 5002 udp 1800
   ```

2. Run the program with the configuration file as the only command-line argument:

   ```bash
   ./packet_redirection redirections.config
   ```

   This command will read the redirection configurations from the `redirections.config` file and execute them one by one.

**Running a Single Redirection Using Command-Line Arguments:**

1. If you want to run a single redirection without using a configuration file, provide the required parameters as command-line arguments.

   Example for a single redirection:

   ```bash
   ./packet_redirection 192.168.1.10 22 192.168.1.20 2222 192.168.1.30 22 tcp 3600
   ```

   In this example, you specify the sending IP, sending port, redirection IP, redirection port, receiving IP, receiving port, protocol (tcp/udp), and duration.

**Error Handling:**

- If the configuration file specified as a command-line argument doesn't exist, the program will display an error message.
- If the command-line arguments are not provided correctly or are incomplete, the program will display a usage message with the correct syntax.

Ensure that you have appropriate permissions and configurations for the specified network settings. Be aware that unauthorized interception or redirection of network traffic can have legal and ethical implications, so use this tool responsibly and within the bounds of applicable laws and regulations.






I can't draw diagrams, but I can describe how the functions in the `packet_redirection` program interact with each other:

1. **main Function**:
   - The `main` function is the entry point of the program.
   - It checks the command-line arguments to determine the mode of operation.
   - If a configuration file is provided, it attempts to open and read the file, executing redirections as specified in the file.
   - If no configuration file is provided and the correct number of command-line arguments is given, it executes a single redirection based on the provided arguments.
   - It provides error handling for incorrect or incomplete command-line arguments.

2. **create_and_bind and create_and_connect Functions**:
   - These functions are used to create sockets and establish connections.
   - They take IP addresses, port numbers, and socket types as input and return socket descriptors.
   - `create_and_bind` is used for local sockets.
   - `create_and_connect` is used for remote connections.

3. **forward Function**:
   - The `forward` function is responsible for forwarding data between sockets.
   - It reads data from one socket and sends it to another socket.

4. **forward_packets_tcp and forward_packets_udp Functions**:
   - These functions are responsible for packet redirection for TCP and UDP traffic, respectively.
   - They set up local and remote sockets, listen for incoming connections (in the case of TCP), and forward packets using the `forward` function.
   - These functions use `select` to monitor socket activity and handle bi-directional traffic.

5. **parse_config_line Function**:
   - The `parse_config_line` function parses a line from the configuration file and fills in the `RedirectionArgs` structure.
   - It performs parsing and validation of parameters from the configuration file.

6. **RedirectionArgs Structure**:
   - This structure holds the parameters for a single redirection:
     - `sending_ip` and `sending_port`: Local IP and port for receiving packets.
     - `redirection_ip` and `redirection_port`: Remote IP and port for redirection.
     - `recv_ip` and `recv_port`: Final destination IP and port.
     - `is_tcp`: Specifies whether the protocol is TCP (1) or UDP (0).
     - `duration`: Duration of the redirection.

These functions and data structures work together to either read and execute multiple redirections from a configuration file or run a single redirection based on command-line arguments. The program uses a combination of socket operations, `select`, and data forwarding to achieve the packet redirection functionality.
/////


The `create_and_bind` and `create_and_connect` functions both deal with socket operations, but they serve different purposes and are used in different scenarios:

1. **`create_and_bind` Function**:
   - Purpose: This function is used to create a socket and bind it to a specific local IP address and port number. It prepares the socket for listening for incoming connections, primarily for server-side applications.
   - Use Case: It is typically used in server programs that need to accept incoming connections from clients.

2. **`create_and_connect` Function**:
   - Purpose: This function is used to create a socket and establish a connection to a remote IP address and port number. It is used to initiate a connection to a remote server or service, primarily for client-side applications.
   - Use Case: It is used when a client program needs to connect to a server to send or receive data.

Here's a more detailed explanation of each function:

**`create_and_bind` Function**:
- Creates a socket using the `socket` function with a specified socket type (e.g., SOCK_STREAM for TCP or SOCK_DGRAM for UDP).
- Binds the socket to a local IP address and port using the `bind` function. This makes the socket ready to accept incoming connections on the specified IP address and port.
- It is typically used on the server side to set up a listening socket, waiting for incoming connection requests from clients.
- After binding, the server can call `listen` to start listening for incoming connections.

**`create_and_connect` Function**:
- Creates a socket using the `socket` function with a specified socket type (e.g., SOCK_STREAM for TCP or SOCK_DGRAM for UDP).
- Establishes a connection to a remote IP address and port using the `connect` function. This initiates a connection to a remote server.
- It is typically used on the client side to establish a connection to a remote server or service.
- After a successful connection, the client can use the socket to send and receive data with the remote server.

In summary, the main difference between the two functions is their intended use:

- `create_and_bind` is used for server-side applications to set up listening sockets.
- `create_and_connect` is used for client-side applications to initiate connections to remote servers.


/////

The `forward` function is a crucial part of the `packet_redirection` program, responsible for forwarding data between two sockets. It plays a pivotal role in ensuring that data received on one socket is sent to another socket. Here's an explanation of how the `forward` function works:

Function Signature:
```c
void forward(int from_sock, int to_sock);
```

Parameters:
- `from_sock`: The socket descriptor from which data will be read.
- `to_sock`: The socket descriptor to which data will be sent.

Function Description:
- The `forward` function takes two socket descriptors as parameters, `from_sock` and `to_sock`. These sockets represent two endpoints for communication.

- Inside the function, it uses the `recv` function to read data from the `from_sock` socket and stores it in a buffer. The `recv` function is used for receiving data from a socket.

  ```c
  char buffer[BUFFER_SIZE];
  int len = recv(from_sock, buffer, BUFFER_SIZE, 0);
  ```

- If data is successfully received (i.e., `len` is greater than 0), the function proceeds to send this data to the `to_sock` socket using the `send` function. The `send` function is used to send data on a socket.

  ```c
  if (len > 0) {
      send(to_sock, buffer, len, 0);
  }
  ```

- The purpose of this forwarding mechanism is to relay data between two sockets. For example, in the context of packet redirection, data arriving at the local socket (`from_sock`) is forwarded to the remote socket (`to_sock`), and vice versa. This enables communication between the local and remote endpoints.

- The function doesn't perform any data manipulation or interpretation; it merely transfers data from one socket to another.

- The `forward` function is typically called within the main packet redirection loop when there is data available to be forwarded.

Overall, the `forward` function is essential for the core functionality of packet redirection, as it ensures that data can flow bidirectionally between the local and remote endpoints, allowing for the redirection of network traffic.


///////
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

// Utility function to extract the IP header from a packet
struct ip *parse_ip_header(char *packet) {
    return (struct ip *)packet;
}

// Utility function to extract the TCP header from a packet
struct tcphdr *parse_tcp_header(char *packet) {
    struct ip *ip_header = parse_ip_header(packet);
    return (struct tcphdr *)(packet + ip_header->ip_hl * 4);
}

// Utility function to extract the UDP header from a packet
struct udphdr *parse_udp_header(char *packet) {
    struct ip *ip_header = parse_ip_header(packet);
    return (struct udphdr *)(packet + ip_header->ip_hl * 4);
}

// Utility function to make any necessary modifications to a packet before redirection
void modify_packet(char *packet, int packet_length, struct RedirectionArgs *args) {
    struct ip *ip_header = parse_ip_header(packet);

    if (args->is_tcp) {
        // Modify TCP source and destination ports if needed
        struct tcphdr *tcp_header = parse_tcp_header(packet);
        if (ntohs(tcp_header->th_sport) == args->sending_port) {
            tcp_header->th_sport = htons(args->redirection_port);
        } else if (ntohs(tcp_header->th_dport) == args->sending_port) {
            tcp_header->th_dport = htons(args->redirection_port);
        }
    } else {
        // Modify UDP source and destination ports if needed
        struct udphdr *udp_header = parse_udp_header(packet);
        if (ntohs(udp_header->uh_sport) == args->sending_port) {
            udp_header->uh_sport = htons(args->redirection_port);
        } else if (ntohs(udp_header->uh_dport) == args->sending_port) {
            udp_header->uh_dport = htons(args->redirection_port);
        }
    }

    // Recalculate IP checksum (optional, depends on your use case)
    ip_header->ip_sum = 0;
    ip_header->ip_sum = checksum((uint16_t *)ip_header, sizeof(struct ip));
}

// Function to calculate the checksum
uint16_t checksum(uint16_t *addr, int count) {
    unsigned long sum = 0;
    while (count > 1) {
        sum += *addr++;
        count -= 2;
    }

    if (count > 0) {
        sum += *(unsigned char *)addr;
    }

    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }

    return (uint16_t)~sum;
}



//////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <netdb.h>
#include <sys/select.h>
#include <stdbool.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#define BUFFER_SIZE 4096

// Structure to hold redirection parameters
struct RedirectionArgs {
    char sending_ip[16];
    int sending_port;
    char redirection_ip[16];
    int redirection_port;
    char recv_ip[16];
    int recv_port;
    int is_tcp;
    int duration;
};

// Function to create and bind a socket
int create_and_bind(const char *ip, int port, int type) {
    // ... (existing implementation)
}

// Function to create and connect a socket to a remote server
int create_and_connect(const char *ip, int port, int type) {
    // ... (existing implementation)
}

// Function to forward data from one socket to another
void forward(int from_sock, int to_sock) {
    // ... (existing implementation)
}

// Function to handle packet redirection for TCP traffic
void forward_packets_tcp(struct RedirectionArgs *args) {
    // ... (existing implementation)
}

// Function to handle packet redirection for UDP traffic
void forward_packets_udp(struct RedirectionArgs *args) {
    // ... (existing implementation)
}

// Function to parse a configuration line and populate RedirectionArgs
int parse_config_line(const char *line, struct RedirectionArgs *args) {
    // ... (existing implementation)
}

// Utility function to extract the IP header from a packet
struct ip *parse_ip_header(char *packet) {
    // ... (implementation)
}

// Utility function to extract the TCP header from a packet
struct tcphdr *parse_tcp_header(char *packet) {
    // ... (implementation)
}

// Utility function to extract the UDP header from a packet
struct udphdr *parse_udp_header(char *packet) {
    // ... (implementation)
}

// Utility function to make any necessary modifications to a packet before redirection
void modify_packet(char *packet, int packet_length, struct RedirectionArgs *args) {
    // ... (implementation)
}

// Function to calculate the checksum
uint16_t checksum(uint16_t *addr, int count) {
    // ... (implementation)
}

int main(int argc, char *argv[]) {
    // ... (main function as before)
}

   
//////// monitor_redirection_status

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <netdb.h>
#include <sys/select.h>
#include <stdbool.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#define BUFFER_SIZE 4096

// ... (Previous code including utility functions)

// Function to periodically monitor the redirection status
void monitor_redirection_status(struct RedirectionArgs *args) {
    while (1) {
        // Check if the redirection is still active
        int sending_sock = create_and_bind(args->sending_ip, args->sending_port, args->is_tcp ? SOCK_STREAM : SOCK_DGRAM);
        int redirection_sock = create_and_connect(args->redirection_ip, args->redirection_port, args->is_tcp ? SOCK_STREAM : SOCK_DGRAM);

        // Attempt to send a test packet and see if it succeeds
        char test_packet[8] = "PING123";
        if (send(sending_sock, test_packet, sizeof(test_packet), 0) != -1) {
            // Redirection is active
            printf("Redirection is active for %s:%d -> %s:%d\n",
                   args->sending_ip, args->sending_port,
                   args->redirection_ip, args->redirection_port);
        } else {
            // Redirection is not active
            printf("Redirection is no longer active for %s:%d -> %s:%d\n",
                   args->sending_ip, args->sending_port,
                   args->redirection_ip, args->redirection_port);
        }

        // Close the sockets
        close(sending_sock);
        close(redirection_sock);

        sleep(60); // Sleep for 60 seconds (adjust the interval as needed)
    }
}

int main(int argc, char *argv[]) {
    // ... (Previous main function code)

    if (args.is_tcp) {
        forward_packets_tcp(&args);
    } else {
        forward_packets_udp(&args);
    }

    // Start the redirection status monitoring in the background
    // Pass the 'args' structure to monitor the specified redirection
    // You can customize the monitoring logic and interval as needed
    monitor_redirection_status(&args);

    return 0;
}




#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <netdb.h>
#include <sys/select.h>
#include <stdbool.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#define BUFFER_SIZE 4096

// Structure to hold redirection parameters
struct RedirectionArgs {
    char sending_ip[16];
    int sending_port;
    char redirection_ip[16];
    int redirection_port;
    char recv_ip[16];
    int recv_port;
    int is_tcp;
    int duration;
};

// Function to handle errors and exit with an error message
void error_exit(const char *message);

// Function to create a socket
int create_socket(int protocol, int sock_type);

// Function to create and connect a socket to a remote server
int create_and_connect(const char *host, int port, int sock_type);

// Function to forward data from one socket to another
void forward(int src_sock, int dest_sock);

// Function to handle packet redirection for TCP traffic
void forward_packets_tcp(struct RedirectionArgs *args);

// Function to handle packet redirection for UDP traffic
void forward_packets_udp(struct RedirectionArgs *args);

// Function to parse a configuration line and populate RedirectionArgs
int parse_config_line(const char *line, struct RedirectionArgs *args);

// Utility function to extract the IP header from a packet
struct ip *parse_ip_header(char *packet);

// Utility function to extract the TCP header from a packet
struct tcphdr *parse_tcp_header(char *packet);

// Utility function to extract the UDP header from a packet
struct udphdr *parse_udp_header(char *packet);

// Utility function to make any necessary modifications to a packet before redirection
void modify_packet(char *packet, int packet_length, struct RedirectionArgs *args);

// Function to calculate the checksum
uint16_t checksum(uint16_t *addr, int count);

// Function to periodically monitor the redirection status
void monitor_redirection_status(struct RedirectionArgs *args);

// The main function to handle command-line arguments and start redirections
int main(int argc, char *argv[]);










/////pcap 

#include <stdio.h>
#include <pcap.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <arpa/inet.h>

struct redirection_rules {
    char source_ip[16];
    char destination_ip[16];
    int source_port;
    int destination_port;
} rules;

void initialize_capture(pcap_t **handle, const char *device) {
    char errbuf[PCAP_ERRBUF_SIZE];
    *handle = pcap_open_live(device, BUFSIZ, 1, 1000, errbuf);
    if (*handle == NULL) {
        report_error(errbuf);
    }
}

void configure_redirection_rules() {
    strcpy(rules.source_ip, "192.168.1.10");
    rules.source_port = 80;
    strcpy(rules.destination_ip, "192.168.1.20");
    rules.destination_port = 8080;
}

void packet_handler(u_char *user_data, const struct pcap_pkthdr *pkthdr, const u_char *packet) {
    if (is_packet_tcp(packet)) {
        handle_tcp_packet(packet);
    } else if (is_packet_udp(packet)) {
        handle_udp_packet(packet);
    }
}

void handle_tcp_packet(const u_char *packet) {
    struct tcphdr *tcp_header = parse_tcp_header(packet);
    modify_packet((u_char *)packet);
    log_packet_details(packet);
    redirect_tcp_packet((u_char *)packet, tcp_header);
}

void handle_udp_packet(const u_char *packet) {
    struct udphdr *udp_header = parse_udp_header(packet);
    modify_packet((u_char *)packet);
    log_packet_details(packet);
    redirect_udp_packet((u_char *)packet, udp_header);
}

int is_packet_tcp(const u_char *packet) {
    struct ip *ip_header = parse_ip_header(packet);
    return ip_header->ip_p == IPPROTO_TCP;
}

int is_packet_udp(const u_char *packet) {
    struct ip *ip_header = parse_ip_header(packet);
    return ip_header->ip_p == IPPROTO_UDP;
}

void redirect_tcp_packet(u_char *packet, struct tcphdr *tcp_header) {
    struct ip *ip_header = parse_ip_header(packet);
    if (strcmp(inet_ntoa(ip_header->ip_dst), rules.source_ip) == 0 && ntohs(tcp_header->dest) == rules.source_port) {
        inet_aton(rules.destination_ip, &(ip_header->ip_dst));
        tcp_header->dest = htons(rules.destination_port);
        printf("TCP packet redirected to %s:%d\n", rules.destination_ip, rules.destination_port);
    }
}

void redirect_udp_packet(u_char *packet, struct udphdr *udp_header) {
    struct ip *ip_header = parse_ip_header(packet);
    if (strcmp(inet_ntoa(ip_header->ip_dst), rules.source_ip) == 0 && ntohs(udp_header->dest) == rules.source_port) {
        inet_aton(rules.destination_ip, &(ip_header->ip_dst));
        udp_header->dest = htons(rules.destination_port);
        printf("UDP packet redirected to %s:%d\n", rules.destination_ip, rules.destination_port);
    }
}

void log_packet_details(const u_char *packet) {
    struct ip *ip_header = parse_ip_header(packet);
    printf("Packet: %s -> %s\n", inet_ntoa(ip_header->ip_src), inet_ntoa(ip_header->ip_dst));
}

void report_error(const char *error_message) {
    fprintf(stderr, "Error: %s\n", error_message);
}

struct ip *parse_ip_header(const u_char *packet) {
    return (struct ip *)(packet + 14);
}

struct tcphdr *parse_tcp_header(const u_char *packet) {
    struct ip *ip_header = parse_ip_header(packet);
    return (struct tcphdr *)(packet + 14 + (ip_header->ip_hl << 2));
}

struct udphdr *parse_udp_header(const u_char *packet) {
    struct ip *ip_header = parse_ip_header(packet);
    return (struct udphdr *)(packet + 14 + (ip_header->ip_hl << 2));
}

void modify_packet(u_char *packet) {
    // For this example, we aren't performing any extra modifications.
    // But this is where you'd add code if you wanted to modify packet payload, etc.
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <interface>\n", argv[0]);
        return 1;
    }

    pcap_t *handle;
    initialize_capture(&handle, argv[1]);
    configure_redirection_rules();
    pcap_loop(handle, 0, packet_handler, NULL);
    pcap_close(handle);
    return 0;
}


To utilize the provided code, you'll need to follow these steps:

1. **Install the Necessary Libraries**:

   Before you can compile and run the program, you need to have the `libpcap` development libraries installed. The installation procedure varies based on your OS. Here's how to do it on some common systems:

   - **Ubuntu/Debian**:
     ```bash
     sudo apt-get update
     sudo apt-get install libpcap-dev
     ```

   - **Fedora**:
     ```bash
     sudo dnf install libpcap-devel
     ```

   - **CentOS/RedHat**:
     ```bash
     sudo yum install libpcap-devel
     ```

   - **macOS** (using Homebrew):
     ```bash
     brew install libpcap
     ```

2. **Compile the Code**:

   Save the code to a file, e.g., `packet_redirect.c`. Then, compile the code using `gcc`:

   ```bash
   gcc packet_redirect.c -o packet_redirect -lpcap
   ```

   This will generate an executable named `packet_redirect`.

3. **Run the Program**:

   Since packet capturing typically requires root privileges, run the program with `sudo`:

   ```bash
   sudo ./packet_redirect <interface_name>
   ```

   Replace `<interface_name>` with the name of the network interface you want to capture packets from (e.g., `eth0`, `wlan0`, etc.).

   You can list available network interfaces using the `ifconfig` command (or `ip a` on some systems).

4. **Monitor and Test**:

   Once the program is running, any packets meeting the criteria specified in the `configure_redirection_rules()` function (in the example, any TCP packets heading to `192.168.1.10` on port `80`) will be logged and their destination will be changed as per the rules.

   You can send test packets using tools like `netcat` or `telnet` and observe the program's output to ensure it's working.

5. **Termination**:

   To stop the program, you can usually use `Ctrl+C` in the terminal.

6. **Refinements**:

   The code provided is a basic skeleton. Depending on your needs, you might want to:

   - Add more sophisticated redirection rules.
   - Handle potential errors and exceptions more gracefully.
   - Address performance considerations if dealing with a large volume of packets.
   - Properly handle packet checksums when modifying packet contents.

Remember, this code is for educational purposes. Deploying such a program in a production environment, especially on a live network, requires careful consideration of its implications, thorough testing, and adherence to relevant laws and best practices.



/////////////

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <netdb.h>
#include <sys/select.h>
#include <stdbool.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#define BUFFER_SIZE 4096

// Structure to hold redirection parameters
struct RedirectionArgs {
    char sending_ip[16];
    int sending_port;
    char redirection_ip[16];
    int redirection_port;
    char recv_ip[16];
    int recv_port;
    int is_tcp;
    int duration;
};

// Function to handle errors and exit with an error message
void error_exit(const char *message) {
    perror(message);
    exit(1);
}

// Function to create a socket
int create_socket(int protocol, int sock_type) {
    int sockfd = socket(AF_INET, sock_type, protocol);
    if (sockfd < 0) error_exit("socket creation failed");
    return sockfd;
}

// Function to create and connect a socket to a remote server
int create_and_connect(const char *host, int port, int sock_type) {
    struct addrinfo hints, *res;
    int sockfd;
    char port_str[6];

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = sock_type;

    sprintf(port_str, "%d", port);
    if (getaddrinfo(host, port_str, &hints, &res) != 0)
        error_exit("getaddrinfo failed");

    sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (sockfd < 0)
        error_exit("socket creation failed");

    if (connect(sockfd, res->ai_addr, res->ai_addrlen) < 0)
        error_exit("connect failed");

    freeaddrinfo(res);
    return sockfd;
}

// Function to forward data from one socket to another
void forward(int src_sock, int dest_sock) {
    char buffer[BUFFER_SIZE];
    int len = recv(src_sock, buffer, BUFFER_SIZE, 0);
    if (len > 0) {
        send(dest_sock, buffer, len, 0);
    }
}

// Function to handle packet redirection for TCP traffic
void forward_packets_tcp(struct RedirectionArgs *args) {
    int local_sock = create_socket(0, SOCK_STREAM);
    int remote_sock = create_and_connect(args->redirection_ip, args->redirection_port, SOCK_STREAM);

    listen(local_sock, 5);
    struct sockaddr_in client_addr;
    socklen_t addr_len = sizeof(client_addr);
    int new_local_sock = accept(local_sock, (struct sockaddr*)&client_addr, &addr_len);
    if (new_local_sock < 0)
        error_exit("accept failed");
    close(local_sock);
    local_sock = new_local_sock;

    struct timeval timeout;
    timeout.tv_sec = args->duration;
    timeout.tv_usec = 0;

    fd_set readfds;

    while (1) {
        FD_ZERO(&readfds);
        FD_SET(local_sock, &readfds);
        FD_SET(remote_sock, &readfds);

        int activity = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);
        if (activity < 0) error_exit("select error");
        if (activity == 0) break;

        if (FD_ISSET(local_sock, &readfds)) {
            forward(local_sock, remote_sock);
        }

        if (FD_ISSET(remote_sock, &readfds)) {
            forward(remote_sock, local_sock);
        }
    }

    close(local_sock);
    close(remote_sock);
}

// Function to handle packet redirection for UDP traffic
void forward_packets_udp(struct RedirectionArgs *args) {
    int local_sock = create_socket(0, SOCK_DGRAM);
    int remote_sock = create_and_connect(args->redirection_ip, args->redirection_port, SOCK_DGRAM);

    struct timeval timeout;
    timeout.tv_sec = args->duration;
    timeout.tv_usec = 0;

    fd_set readfds;

    while (1) {
        FD_ZERO(&readfds);
        FD_SET(local_sock, &readfds);
        FD_SET(remote_sock, &readfds);

        int activity = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);
        if (activity < 0) error_exit("select error");
        if (activity == 0) break;

        if (FD_ISSET(local_sock, &readfds)) {
            forward(local_sock, remote_sock);
        }

        if (FD_ISSET(remote_sock, &readfds)) {
            forward(remote_sock, local_sock);
        }
    }

    close(local_sock);
    close(remote_sock);
}

// Function to parse a configuration line and populate RedirectionArgs
int parse_config_line(const char *line, struct RedirectionArgs *args) {
    return sscanf(line, "%15[^:]:%d %15[^:]:%d %15[^:]:%d %d %d %d",
                  args->sending_ip, &args->sending_port,
                  args->redirection_ip, &args->redirection_port,
                  args->recv_ip, &args->recv_port,
                  &args->is_tcp, &args->duration) == 8;
}

// Utility function to extract the IP header from a packet
struct ip *parse_ip_header(char *packet) {
    return (struct ip *)packet;
}

// Utility function to extract the TCP header from a packet
struct tcphdr *parse_tcp_header(char *packet) {
    struct ip *ip_header = parse_ip_header(packet);
    return (struct tcphdr *)(packet + ip_header->ip_hl * 4);
}

// Utility function to extract the UDP header from a packet
struct udphdr *parse_udp_header(char *packet) {
    struct ip *ip_header = parse_ip_header(packet);
    return (struct udphdr *)(packet + ip_header->ip_hl * 4);
}

// Utility function to make any necessary modifications to a packet before redirection
void modify_packet(char *packet, int packet_length, struct RedirectionArgs *args) {
    struct ip *ip_header = parse_ip_header(packet);

    if (args->is_tcp) {
        struct tcphdr *tcp_header = parse_tcp_header(packet);
        if (ntohs(tcp_header->th_sport) == args->sending_port) {
            tcp_header->th_sport = htons(args->redirection_port);
        } else if (ntohs(tcp_header->th_dport) == args->sending_port) {
            tcp_header->th_dport = htons(args->redirection_port);
        }
    } else {
        struct udphdr *udp_header = parse_udp_header(packet);
        if (ntohs(udp_header->uh_sport) == args->sending_port) {
            udp_header->uh_sport = htons(args->redirection_port);
        } else if (ntohs(udp_header->uh_dport) == args->sending_port) {
            udp_header->uh_dport = htons(args->redirection_port);
       

 }
    }

    // Recalculate the IP header checksum
    ip_header->ip_sum = 0;
    ip_header->ip_sum = checksum((uint16_t *)ip_header, ip_header->ip_hl * 4);
}

// Function to calculate the checksum
uint16_t checksum(uint16_t *addr, int count) {
    unsigned long sum = 0;
    while (count > 1) {
        sum += *addr++;
        count -= 2;
    }
    if (count > 0) {
        sum += *(uint8_t *)addr;
    }
    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    return (uint16_t)~sum;
}

// Function to periodically monitor the redirection status
void monitor_redirection_status(struct RedirectionArgs *args) {
    while (1) {
        // Check if the redirection is still active
        int sending_sock = create_and_bind(args->sending_ip, args->sending_port, args->is_tcp ? SOCK_STREAM : SOCK_DGRAM);
        int redirection_sock = create_and_connect(args->redirection_ip, args->redirection_port, args->is_tcp ? SOCK_STREAM : SOCK_DGRAM);

        // Attempt to send a test packet and see if it succeeds
        char test_packet[8] = "PING123";
        if (send(sending_sock, test_packet, sizeof(test_packet), 0) != -1) {
            // Redirection is active
            printf("Redirection is active for %s:%d -> %s:%d\n",
                   args->sending_ip, args->sending_port,
                   args->redirection_ip, args->redirection_port);
        } else {
            // Redirection is not active
            printf("Redirection is no longer active for %s:%d -> %s:%d\n",
                   args->sending_ip, args->sending_port,
                   args->redirection_ip, args->redirection_port);
        }

        // Close the sockets
        close(sending_sock);
        close(redirection_sock);

        sleep(60); // Sleep for 60 seconds (adjust the interval as needed)
    }
}

// The main function to handle command-line arguments and start redirections
int main(int argc, char *argv[]) {
    if (argc == 2) {
        // Check if a configuration file is provided
        const char *config_file_path = argv[1];
        FILE *config_file = fopen(config_file_path, "r");

        if (config_file) {
            // Configuration file exists, read and execute configurations
            char line[1024];
            while (fgets(line, sizeof(line), config_file)) {
                struct RedirectionArgs args;
                if (parse_config_line(line, &args)) {
                    if (args.is_tcp) {
                        forward_packets_tcp(&args);
                    } else {
                        forward_packets_udp(&args);
                    }
                }
            }
            fclose(config_file);
        } else {
            fprintf(stderr, "Error: Could not open the specified configuration file.\n");
            exit(EXIT_FAILURE);
        }
    } else if (argc == 9) {
        // No configuration file, use command-line arguments for a single redirection
        struct RedirectionArgs args;
        strcpy(args.sending_ip, argv[1]);
        args.sending_port = atoi(argv[2]);
        strcpy(args.redirection_ip, argv[3]);
        args.redirection_port = atoi(argv[4]);
        strcpy(args.recv_ip, argv[5]);
        args.recv_port = atoi(argv[6]);
        args.is_tcp = strcmp(argv[7], "tcp") == 0;
        args.duration = atoi(argv[8]);

        if (args.is_tcp) {
            forward_packets_tcp(&args);
        } else {
            forward_packets_udp(&args);
        }
    } else {
        fprintf(stderr, "Usage: %s <Config_File> OR %s <Sending_IP> <Sending_Port> <Redirection_IP> <Redirection_Port> <Recv_IP> <Recv_Port> <tcp|udp> <Duration>\n", argv[0], argv[0]);
        exit(EXIT_FAILURE);
    }

    return 0;
}

//////
To run the `packet_redirection` program, you have two options: using a configuration file or providing command-line arguments for a single redirection. Here's how to run the program for both scenarios:

### Using a Configuration File

1. Create a configuration file (e.g., `config.txt`) with redirection configurations. Each line in the file should contain a configuration in the following format:

   ```
   Sending_IP:Sending_Port Redirection_IP:Redirection_Port Recv_IP:Recv_Port tcp|udp Duration
   ```

   For example:

   ```
   192.168.1.100:8080 10.0.0.1:8080 192.168.1.200:8080 tcp 3600
   ```

   This example configuration redirects TCP traffic from `192.168.1.100:8080` to `10.0.0.1:8080` with a duration of 3600 seconds.

2. Save the configuration file.

3. Open your terminal.

4. Run the `packet_redirection` program by specifying the configuration file as an argument:

   ```bash
   ./packet_redirection config.txt
   ```

   Replace `config.txt` with the actual path to your configuration file.

### Using Command-Line Arguments (Single Redirection)

1. Open your terminal.

2. Run the `packet_redirection` program with command-line arguments for a single redirection:

   ```bash
   ./packet_redirection Sending_IP Sending_Port Redirection_IP Redirection_Port Recv_IP Recv_Port tcp|udp Duration
   ```

   Replace the placeholders with your desired values. For example:

   ```bash
   ./packet_redirection 192.168.1.100 8080 10.0.0.1 8080 192.168.1.200 8080 tcp 3600
   ```

   This command will redirect TCP traffic from `192.168.1.100:8080` to `10.0.0.1:8080` with a duration of 3600 seconds.

Make sure to choose the appropriate method (configuration file or command-line arguments) based on your specific use case.










////////////with prototypes




#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <netdb.h>
#include <sys/select.h>
#include <stdbool.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>

#define BUFFER_SIZE 4096

// Function prototypes
void error_exit(const char *message);
int create_socket(int protocol, int sock_type);
int create_and_connect(const char *host, int port, int sock_type);
void forward(int src_sock, int dest_sock);
void forward_packets_tcp(struct RedirectionArgs *args);
void forward_packets_udp(struct RedirectionArgs *args);
int parse_config_line(const char *line, struct RedirectionArgs *args);
struct ip *parse_ip_header(char *packet);
struct tcphdr *parse_tcp_header(char *packet);
struct udphdr *parse_udp_header(char *packet);
void modify_packet(char *packet, int packet_length, struct RedirectionArgs *args);
uint16_t checksum(uint16_t *addr, int count);
void monitor_redirection_status(struct RedirectionArgs *args);

struct RedirectionArgs {
    char sending_ip[16];
    int sending_port;
    char redirection_ip[16];
    int redirection_port;
    char recv_ip[16];
    int recv_port;
    int is_tcp;
    int duration;
};

void error_exit(const char *message) {
    perror(message);
    exit(1);
}

int create_socket(int protocol, int sock_type) {
    int sockfd = socket(AF_INET, sock_type, protocol);
    if (sockfd < 0) error_exit("socket creation failed");
    return sockfd;
}

int create_and_connect(const char *host, int port, int sock_type) {
    struct addrinfo hints, *res;
    int sockfd;
    char port_str[6];

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = sock_type;

    sprintf(port_str, "%d", port);
    if (getaddrinfo(host, port_str, &hints, &res) != 0)
        error_exit("getaddrinfo failed");

    sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (sockfd < 0)
        error_exit("socket creation failed");

    if (connect(sockfd, res->ai_addr, res->ai_addrlen) < 0)
        error_exit("connect failed");

    freeaddrinfo(res);
    return sockfd;
}

void forward(int src_sock, int dest_sock) {
    char buffer[BUFFER_SIZE];
    int len = recv(src_sock, buffer, BUFFER_SIZE, 0);
    if (len > 0) {
        send(dest_sock, buffer, len, 0);
    }
}

void forward_packets_tcp(struct RedirectionArgs *args) {
    int local_sock = create_socket(0, SOCK_STREAM);
    int remote_sock = create_and_connect(args->redirection_ip, args->redirection_port, SOCK_STREAM);

    listen(local_sock, 5);
    struct sockaddr_in client_addr;
    socklen_t addr_len = sizeof(client_addr);
    int new_local_sock = accept(local_sock, (struct sockaddr*)&client_addr, &addr_len);
    if (new_local_sock < 0)
        error_exit("accept failed");
    close(local_sock);
    local_sock = new_local_sock;

    struct timeval timeout;
    timeout.tv_sec = args->duration;
    timeout.tv_usec = 0;

    fd_set readfds;

    while (1) {
        FD_ZERO(&readfds);
        FD_SET(local_sock, &readfds);
        FD_SET(remote_sock, &readfds);

        int activity = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);
        if (activity < 0) error_exit("select error");
        if (activity == 0) break;

        if (FD_ISSET(local_sock, &readfds)) {
            forward(local_sock, remote_sock);
        }

        if (FD_ISSET(remote_sock, &readfds)) {
            forward(remote_sock, local_sock);
        }
    }

    close(local_sock);
    close(remote_sock);
}

void forward_packets_udp(struct RedirectionArgs *args) {
    int local_sock = create_socket(0, SOCK_DGRAM);
    int remote_sock = create_and_connect(args->redirection_ip, args->redirection_port, SOCK_DGRAM);

    struct timeval timeout;
    timeout.tv_sec = args->duration;
    timeout.tv_usec = 0;

    fd_set readfds;

    while (1) {
        FD_ZERO(&readfds);
        FD_SET(local_sock, &readfds);
        FD_SET(remote_sock, &readfds);

        int activity = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);
        if (activity < 0) error_exit("select error");
        if (activity == 0) break;

        if (FD_ISSET(local_sock, &readfds)) {
            forward(local_sock, remote_sock);
        }

        if (FD_ISSET(remote_sock, &readfds)) {
            forward(remote_sock, local_sock);
        }
    }

    close(local_sock);
    close(remote_sock);
}

int parse_config_line(const char *line, struct RedirectionArgs *args) {
    return sscanf(line, "%15[^:]:%d %15[^:]:%d %15[^:]:%d %d %d %d",
                  args->sending_ip, &args->sending_port,
                  args->redirection_ip, &args->redirection_port,
                  args->recv_ip, &args->recv_port,
                  &args->is_tcp, &args->duration) == 8;
}

struct ip *parse_ip_header(char *packet) {
    return (struct ip *)packet;
}

struct tcphdr *parse_tcp_header(char *packet) {
    struct ip *ip_header = parse_ip_header(packet);
    return (struct tcphdr *)(packet + ip_header->ip_hl * 4);
}

struct udphdr *parse_udp_header(char *packet) {
    struct ip *ip_header = parse_ip_header(packet);
    return (struct udphdr *)(packet + ip_header->ip_hl * 4);
}

void modify_packet(char *packet, int packet_length, struct RedirectionArgs *args) {
    struct ip *ip_header = parse_ip_header(packet);

    if (args->is_tcp) {
        struct tcphdr *tcp_header = parse_tcp_header(packet);
        if (ntohs(tcp_header->th_sport) == args->sending_port) {
            tcp_header->th_sport = htons(args->redirection_port);
        } else if (ntohs(tcp_header->th_sport) == args->redirection_port) {
            tcp_header->th_sport = htons(args->sending_port);
        }
        ip_header->ip_sum = 0;
    } else {
        struct udphdr *udp_header = parse_udp_header(packet);
        if (ntohs(udp_header->uh_sport) == args->sending_port) {
            udp_header->uh_sport = htons(args->redirection_port);
        } else if (ntohs(udp_header->uh_sport) == args->redirection_port) {
            udp_header->uh_sport = htons(args->sending_port);
        }
    }

    // Recalculate the IP header checksum
    ip_header->ip_sum = 0;
    ip_header->ip_sum = checksum((uint16_t *)ip_header, ip_header->ip_hl * 4);
}

uint16_t checksum(uint16_t *addr, int count) {
    unsigned long sum = 0;
    while (count > 1) {
        sum += *addr++;
        count -= 2;
    }
    if (count > 0) {
        sum += *(uint8_t *)addr;
    }
    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    return (uint16_t)~sum;
}

void monitor_redirection_status(struct RedirectionArgs *args) {
    while (1) {
        // Check if the redirection is still active
        int sending_sock = create_socket(0, args->is_tcp ? SOCK_STREAM : SOCK_DGRAM);
        int redirection_sock = create_and_connect(args->redirection_ip, args->redirection_port, args->is_tcp ? SOCK_STREAM : SOCK_DGRAM);

        // Attempt to send a test packet and see if it succeeds
        char test_packet[8] = "PING123";
        if (send(sending_sock, test_packet, sizeof(test_packet), 0) != -1) {
            // Redirection is active
            printf("Redirection is active for %s:%d -> %s:%d\n",
                   args->sending_ip, args->sending_port,
                   args->redirection_ip, args->redirection_port);
        } else {
            // Redirection is not active
            printf("Redirection is no longer active for %s:%d -> %s:%d\n",
                   args->sending_ip, args->sending_port,
                   args->redirection_ip, args->redirection_port);
        }

        // Close the sockets
        close(sending_sock);
        close(redirection_sock);

        sleep(60); // Sleep for 60 seconds (adjust the interval as needed)
    }
}

int main(int argc, char *argv[]) {
    if (argc == 2) {
        // Check if a configuration file is provided
        const char *config_file_path = argv[1];
        FILE *config_file = fopen(config_file_path, "r");

        if (config_file) {
            // Configuration file exists, read and execute configurations
            char line[1024];
            while (fgets(line, sizeof(line), config_file)) {
                struct RedirectionArgs args;
                if (parse_config_line(line, &args)) {
                    if (args.is_tcp) {
                        forward_packets_tcp(&args);
                    } else {
                        forward_packets_udp(&args);
                    }
                     
                    // Start monitoring the redirection status
                    //monitor_redirection_status(&args);
                }
            }
            fclose(config_file);
        } else {
            fprintf(stderr, "Error: Could not open the specified configuration file.\n");
            exit(EXIT_FAILURE);
        }
    } else if (argc == 9) {
        // No configuration file, use command-line arguments for a single redirection
        struct RedirectionArgs args;
        strcpy(args.sending_ip, argv[1]);
        args.sending_port = atoi(argv[2]);
        strcpy(args.redirection_ip, argv[3]);
        args.redirection_port = atoi(argv[4]);
        strcpy(args.recv_ip, argv[5]);
        args.recv_port = atoi(argv[6]);
        args.is_tcp = strcmp(argv[7], "tcp") == 0;
        args.duration = atoi(argv[8]);

        if (args.is_tcp) {
            forward_packets_tcp(&args);
        } else {
            forward_packets_udp(&args);
        }
               // Start monitoring the redirection status
        //monitor_redirection_status(&args);
    } else {
        fprintf(stderr, "Usage: %s <Config_File> OR %s <Sending_IP> <Sending_Port> <Redirection_IP> <Redirection_Port> <Recv_IP> <Recv_Port> <tcp|udp> <Duration>\n", argv[0], argv[0]);
        exit(EXIT_FAILURE);
    }

    return 0;
}



/////////////

<Sending_IP>: The IP address the program will listen on for incoming packets.
<Sending_Port>: The port number the program will listen on for incoming packets.
<Redirection_IP>: The IP address of the redirection server.
<Redirection_Port>: The port number of the redirection server.
<Recv_IP>: The IP address of the final receiving server.
<Recv_Port>: The port number of the final receiving server.
<tcp|udp>: Specify tcp for TCP traffic (e.g., SSH) or udp for UDP traffic.
<Duration>: The duration (in seconds) for which the program should run before 







#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/select.h>
#include <sys/time.h>
#include <time.h>

// Structure to hold the necessary parameters for redirection
struct RedirectionArgs {
    char sending_ip[16];
    int sending_port;
    char redirection_ip[16];
    int redirection_port;
    char recv_ip[16];
    int recv_port;
    int is_tcp;
    int duration;
};

// Function to handle errors and exit the program
void error_exit(const char *message) {
    perror(message);
    exit(EXIT_FAILURE);
}

// Function to handle TCP redirection
void handle_tcp(struct RedirectionArgs *args) {
    int server_socket, client_socket, redir_socket;
    struct sockaddr_in server_addr, client_addr, redir_addr;
    char buffer[2048];
    fd_set read_fds, temp_fds;
    int max_fd;

    // Create TCP socket for the server
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        error_exit("Failed to create TCP socket");
    }

    // Set up the server address structure
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(args->sending_port);
    inet_pton(AF_INET, args->sending_ip, &server_addr.sin_addr);

    // Bind the server socket to the specified IP and port
    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        error_exit("TCP bind failed");
    }

    // Listen for incoming connections
    if (listen(server_socket, 5) == -1) {
        error_exit("TCP listen failed");
    }

    FD_ZERO(&read_fds);
    FD_SET(server_socket, &read_fds);
    max_fd = server_socket;

    time_t start_time = time(NULL);

    // Main loop to handle incoming connections and data redirection
    while (1) {
        // Check for the duration to stop the server
        if (time(NULL) - start_time > args->duration) {
            break;
        }

        temp_fds = read_fds;
        select(max_fd + 1, &temp_fds, NULL, NULL, NULL);

        for (int i = 0; i <= max_fd; i++) {
            if (FD_ISSET(i, &temp_fds)) {
                // Handle new connection
                if (i == server_socket) {
                    socklen_t client_len = sizeof(client_addr);
                    client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_len);

                    // Create a socket to connect to the redirection target
                    redir_socket = socket(AF_INET, SOCK_STREAM, 0);
                    if (redir_socket == -1) {
                        error_exit("Failed to create redirection TCP socket");
                    }

                    // Set up the redirection address structure
                    memset(&redir_addr, 0, sizeof(redir_addr));
                    redir_addr.sin_family = AF_INET;
                    redir_addr.sin_port = htons(args->redirection_port);
                    inet_pton(AF_INET, args->redirection_ip, &redir_addr.sin_addr);

                    // Connect to the redirection target
                    if (connect(redir_socket, (struct sockaddr *)&redir_addr, sizeof(redir_addr)) == -1) {
                        error_exit("Failed to connect to redirection server");
                    }

                    FD_SET(client_socket, &read_fds);
                    FD_SET(redir_socket, &read_fds);
                    
                    // Update the max_fd if necessary
                    if (client_socket > max_fd) {
                        max_fd = client_socket;
                    }
                    if (redir_socket > max_fd) {
                        max_fd = redir_socket;
                    }
                } else {
                    // Handle data transfer between client and redirection target
                    ssize_t bytes = recv(i, buffer, sizeof(buffer), 0);
                    if (bytes <= 0) {
                        // Close the socket if no data or error
                        close(i);
                        FD_CLR(i, &read_fds);
                    } else {
                        if (i == client_socket) {
                            send(redir_socket, buffer, bytes, 0);
                        } else if (i == redir_socket) {
                            send(client_socket, buffer, bytes, 0);
                        }
                    }
                }
            }
        }
    }

    // Close the server socket
    close(server_socket);
}

// Function to handle UDP redirection
void handle_udp(struct RedirectionArgs *args) {
    int udp_socket;
    struct sockaddr_in server_addr, client_addr, redir_addr;
    char buffer[2048];
    socklen_t addr_len = sizeof(client_addr);

    // Create UDP socket
    udp_socket = socket(AF_INET, SOCK_DGRAM, 0);
    if (udp_socket == -1) {
        error_exit("Failed to create UDP socket");
    }

    // Set up the server address structure
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(args->sending_port);
    inet_pton(AF_INET, args->sending_ip, &server_addr.sin_addr);

    // Bind the UDP socket to the specified IP and port
    if (bind(udp_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        error_exit("UDP bind failed");
    }

    time_t start_time = time(NULL);

    // Main loop to handle incoming data and redirection
    while (1) {
        // Check for the duration to stop the server
        if (time(NULL) - start_time > args->duration) {
            break;
        }

        ssize_t bytes = recvfrom(udp_socket, buffer, sizeof(buffer), 0, (struct sockaddr *)&client_addr, &addr_len);
        if (bytes > 0) {
            // Set up the redirection address structure
            memset(&redir_addr, 0, sizeof(redir_addr));
            redir_addr.sin_family = AF_INET;
            redir_addr.sin_port = htons(args->redirection_port);
            inet_pton(AF_INET, args->redirection_ip, &redir_addr.sin_addr);

            // Send the received data to the redirection target
            sendto(udp_socket, buffer, bytes, 0, (struct sockaddr *)&redir_addr, sizeof(redir_addr));
        }
    }

    // Close the UDP socket
    close(udp_socket);
}

// Main function
int main(int argc, char *argv[]) {
    // Check for the correct number of command-line arguments
    if (argc != 9) {
        fprintf(stderr, "Usage: %s <Sending_IP> <Sending_Port> <Redirection_IP> <Redirection_Port> <Recv_IP> <Recv_Port> <tcp|udp> <Duration>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    // Populate the RedirectionArgs structure with command-line arguments
    struct RedirectionArgs args;
    strncpy(args.sending_ip, argv[1], sizeof(args.sending_ip));
    args.sending_port = atoi(argv[2]);
    strncpy(args.redirection_ip, argv[3], sizeof(args.redirection_ip));
    args.redirection_port = atoi(argv[4]);
    strncpy(args.recv_ip, argv[5], sizeof(args.recv_ip));
    args.recv_port = atoi(argv[6]);
    args.is_tcp = (strcmp(argv[7], "tcp") == 0) ? 1 : 0;
    args.duration = atoi(argv[8]);

    // Validate the protocol argument
    if (!args.is_tcp && strcmp(argv[7], "udp") != 0) {
        fprintf(stderr, "Invalid protocol specified. Use either 'tcp' or 'udp'.\n");
        exit(EXIT_FAILURE);
    }

    // Call the appropriate handler based on the protocol
    if (args.is_tcp) {
        handle_tcp(&args);
    } else {
        handle_udp(&args);
    }

    return 0;
}



//////

To use the provided redirection program, you need to:

1. **Compile the program**: 
   Use a C compiler (like `gcc`) to compile the code.

   ```bash
   gcc redirector.c -o redirector
   ```

   This will produce an executable named `redirector` in the same directory.

2. **Run the program**:
   Once compiled, you can run the program with the required arguments. The program expects 8 arguments in the order:

   ```bash
   ./redirector <Sending_IP> <Sending_Port> <Redirection_IP> <Redirection_Port> <Recv_IP> <Recv_Port> <tcp|udp> <Duration>
   ```

   - **Sending_IP**: IP where this program will listen.
   - **Sending_Port**: Port where this program will listen.
   - **Redirection_IP**: IP where the data should be forwarded.
   - **Redirection_Port**: Port where the data should be forwarded.
   - **Recv_IP**: (This value isn't used in the provided code. You can provide any valid IP here or modify the program to make use of it if required.)
   - **Recv_Port**: (This value isn't used in the provided code. You can provide any valid port here or modify the program to make use of it if required.)
   - **tcp|udp**: Specify the protocol you want to use. You can either use 'tcp' or 'udp'.
   - **Duration**: The duration (in seconds) for which the redirection should work.

   Example:

   ```bash
   ./redirector 127.0.0.1 8080 192.168.1.100 9090 127.0.0.1 7000 tcp 60
   ```

   This will start the program, and it will listen on IP `127.0.0.1` and port `8080` for incoming TCP connections. When it receives data, it will forward that data to `192.168.1.100` on port `9090`. The program will run for 60 seconds.

3. **Stopping the program**:
   If you want to stop the program before the specified duration, you can do so by pressing `Ctrl+C` in the terminal where the program is running.

Remember, this is a basic redirection program and might not cover all edge cases or provide features like error handling in-depth, logging, or robustness that a production-level redirector might offer. It's a good starting point for understanding the concept and can be expanded upon as needed.




In the given packet redirection program, "Server A" represents the initial sending server from which packets originate, and you want to redirect them through "Server B" (the redirection server) to "Server C" (the final receiving server). The provided program is written to run on Server B (the redirection server). 

For Server A, you don't specifically provide any arguments in the context of this program. Instead, Server A simply sends its packets to Server B's listening IP and port. 

To clarify:

1. **Server A** (Sending Server):
   - Will have applications or services that send packets.
   - Should direct its outgoing packets to Server B's listening address (`<Sending_IP>:<Sending_Port>`).
   - There's no specific requirement mentioned for this server in the context of the provided program, so you just ensure any application or service on Server A sends data to Server B's listening address.

2. **Server B** (Redirection Server, where the provided program runs):
   - Listens on `<Sending_IP>:<Sending_Port>`.
   - Forwards incoming packets to `<Redirection_IP>:<Redirection_Port>`, which should typically be an address on Server C.
   - In this context, Server B takes the arguments as mentioned in the program.

3. **Server C** (Receiving Server):
   - Should be prepared to receive packets from Server B at `<Recv_IP>:<Recv_Port>`.
   - There's no specific requirement mentioned for this server in the context of the provided program.

So, to answer your question: You don't provide arguments to Server A in the context of this program. Instead, you configure any applications or services on Server A to send their packets to the listening address of Server B.



///////
To test the packet redirection program with SSH, you can set up a scenario with three machines:

1. **Server A**: The initial machine you SSH from.
2. **Server B**: The redirection server where the provided program runs.
3. **Server C**: The final target machine you want to SSH into.

Here's a step-by-step process to test the redirection:

1. **Prepare Server C**:
   - Ensure SSH server is installed and running.
     - For Debian/Ubuntu: `sudo apt-get install openssh-server`
     - For RedHat/CentOS: `sudo yum install openssh-server`
   - Start the SSH service:
     ```bash
     sudo service ssh start
     ```

2. **Prepare Server B**:
   - Compile and run the provided redirection program with appropriate arguments.
     For instance, if you want to redirect TCP packets from Server B's IP `192.168.1.2` on port `8080` to Server C's IP `192.168.1.3` on its SSH port `22`, you would run:
     ```bash
     gcc packet_redirect.c -o redirect
     ./redirect 192.168.1.2 8080 192.168.1.3 22 192.168.1.3 22 tcp 3600
     ```
   - This will start the program and it will listen for incoming SSH connections on `192.168.1.2:8080` and redirect them to `192.168.1.3:22`.

3. **SSH from Server A**:
   - SSH into Server B's listening port which will then redirect the SSH request to Server C:
     ```bash
     ssh -p 8080 username@192.168.1.2
     ```
   - Here, `username` is the SSH user on Server C. After entering the password, you should be logged into Server C even though you SSH'ed into Server B's address and port. This indicates the redirection is working.

4. **Monitoring**:
   - On Server B, you should be able to see the incoming and outgoing packets (if you've added print statements or logging in the redirection program).
   - On Server C, you can check the SSH logs (typically in `/var/log/auth.log` on Ubuntu) to see the incoming SSH connection.

Note: For real-world scenarios, ensure your redirection setup is in line with network and security policies. This setup is simplified for testing purposes. SSH can be sensitive to packet delays or losses, so the redirection should be as efficient and reliable as possible to avoid disrupting the SSH session.



///////
Certainly! I'll provide a solution that will read multiple redirection configurations from an INI file and process them serially. If an INI file is provided, the program will use that; otherwise, it will use the command-line arguments.

Here's how it will be structured:

### INI File Structure:
Each redirection will be placed in a separate section. Each section will be named `redirectionX` where `X` is a number.
```ini
[redirection1]
sending_ip = 192.168.1.1
sending_port = 8080
redirection_ip = 192.168.1.2
redirection_port = 8081
recv_ip = 192.168.1.3
recv_port = 22
protocol = tcp
duration = 3600

[redirection2]
sending_ip = 192.168.1.4
sending_port = 8082
redirection_ip = 192.168.1.5
redirection_port = 8083
recv_ip = 192.168.1.6
recv_port = 23
protocol = udp
duration = 1800
```

### Code Changes:

1. Expand the configuration structure to hold an array of redirection configurations:
```c
#define MAX_REDIRECTIONS 10

typedef struct {
    struct RedirectionArgs redirections[MAX_REDIRECTIONS];
    int count;
} Configuration;
```

2. Modify the INI handler to populate redirection configurations:
```c
static int handler(void* user, const char* section, const char* name, const char* value) {
    Configuration* config = (Configuration*)user;
    int index = atoi(&section[strlen("redirection")]) - 1;
    
    if (index < 0 || index >= MAX_REDIRECTIONS) {
        return 0;  // Invalid section number
    }

    struct RedirectionArgs *args = &config->redirections[index];
    config->count = index + 1; // Update count

    #define MATCH(n) strcmp(name, n) == 0
    if (MATCH("sending_ip")) {
        strncpy(args->sending_ip, value, sizeof(args->sending_ip));
    } else if (MATCH("sending_port")) {
        args->sending_port = atoi(value);
    } else if (MATCH("redirection_ip")) {
        strncpy(args->redirection_ip, value, sizeof(args->redirection_ip));
    } else if (MATCH("redirection_port")) {
        args->redirection_port = atoi(value);
    } else if (MATCH("recv_ip")) {
        strncpy(args->recv_ip, value, sizeof(args->recv_ip));
    } else if (MATCH("recv_port")) {
        args->recv_port = atoi(value);
    } else if (MATCH("protocol")) {
        args->is_tcp = strcmp(value, "tcp") == 0 ? 1 : 0;
    } else if (MATCH("duration")) {
        args->duration = atoi(value);
    } else {
        return 0;  /* unknown name, error */
    }
    return 1;
}
```

3. Modify `main()` to either use command-line args or process redirections from the INI file:
```c
int main(int argc, char *argv[]) {
    if (argc == 2) {
        Configuration config = { .count = 0 };
        if (ini_parse(argv[1], handler, &config) < 0) {
            printf("Can't load '%s'\n", argv[1]);
            return 1;
        }

        for (int i = 0; i < config.count; i++) {
            struct RedirectionArgs *args = &config.redirections[i];
            if (args->is_tcp) {
                handle_tcp(args);
            } else {
                handle_udp(args);
            }
        }
    } else if (argc == 9) {
        // ... The existing argument parsing code ...
    } else {
        fprintf(stderr, "Usage: %s <config.ini> OR the usual arguments\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    return 0;
}
```

With these modifications, if an INI file is provided, the program will read multiple redirection configurations and execute them in sequence. If command-line arguments are provided, it will operate on just that single redirection.

////////////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/select.h>
#include <sys/time.h>
#include <time.h>

#define MAX_REDIRECTIONS 10

struct RedirectionArgs {
    char sending_ip[16];
    int sending_port;
    char redirection_ip[16];
    int redirection_port;
    char recv_ip[16];
    int recv_port;
    int is_tcp;
    int duration;
};

typedef struct {
    struct RedirectionArgs redirections[MAX_REDIRECTIONS];
    int count;
} Configuration;

void error_exit(const char *message) {
    perror(message);
    exit(EXIT_FAILURE);
}

// ... handle_tcp and handle_udp functions ...

int parse_ini(const char *filename, Configuration *config) {
    FILE *file = fopen(filename, "r");
    if (!file) return 0;

    char line[256];
    struct RedirectionArgs *current = NULL;

    while (fgets(line, sizeof(line), file)) {
        // Remove newline character
        line[strcspn(line, "\n")] = 0;

        // Check for redirection section
        if (strncmp(line, "[redirection", 12) == 0) {
            int index = atoi(line + 12) - 1;
            if (index >= 0 && index < MAX_REDIRECTIONS) {
                current = &config->redirections[index];
                config->count = index + 1;
            } else {
                current = NULL;
            }
        } else if (current && strchr(line, '=')) {
            char *key = strtok(line, "=");
            char *value = strtok(NULL, "=");

            if (strcmp(key, "sending_ip") == 0) {
                strncpy(current->sending_ip, value, sizeof(current->sending_ip));
            } else if (strcmp(key, "sending_port") == 0) {
                current->sending_port = atoi(value);
            } else if (strcmp(key, "redirection_ip") == 0) {
                strncpy(current->redirection_ip, value, sizeof(current->redirection_ip));
            } else if (strcmp(key, "redirection_port") == 0) {
                current->redirection_port = atoi(value);
            } else if (strcmp(key, "recv_ip") == 0) {
                strncpy(current->recv_ip, value, sizeof(current->recv_ip));
            } else if (strcmp(key, "recv_port") == 0) {
                current->recv_port = atoi(value);
            } else if (strcmp(key, "protocol") == 0) {
                current->is_tcp = strcmp(value, "tcp") == 0 ? 1 : 0;
            } else if (strcmp(key, "duration") == 0) {
                current->duration = atoi(value);
            }
        }
    }

    fclose(file);
    return 1;
}

int main(int argc, char *argv[]) {
    if (argc == 2) {
        Configuration config = { .count = 0 };
        if (!parse_ini(argv[1], &config)) {
            printf("Failed to load '%s'\n", argv[1]);
            return 1;
        }

        for (int i = 0; i < config.count; i++) {
            struct RedirectionArgs *args = &config.redirections[i];
            if (args->is_tcp) {
                handle_tcp(args);
            } else {
                handle_udp(args);
            }
        }
    } else if (argc == 9) {
        // ... Existing argument parsing code ...
    } else {
        fprintf(stderr, "Usage: %s <config.ini> OR the usual arguments\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    return 0;
}
 









 ////////////
 void handle_tcp(struct RedirectionArgs *args) {
    // Declare server, client, and redirection socket descriptors.
    int server_socket, client_socket, redir_socket;

    // Declare structures for the server, client, and redirection addresses.
    struct sockaddr_in server_addr, client_addr, redir_addr;

    // Buffer to temporarily store received data.
    char buffer[2048];

    // Set of socket descriptors to monitor for readability.
    fd_set read_fds, temp_fds;
    int max_fd;

    // Create a socket for the server.
    server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        error_exit("Failed to create TCP socket"); // Exit if socket creation fails.
    }

    // Initialize the server address structure to zero.
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET; // Specify the address family (IPv4).
    server_addr.sin_port = htons(args->sending_port); // Set the port number.
    inet_pton(AF_INET, args->sending_ip, &server_addr.sin_addr); // Convert IP address from string to binary form.

    // Bind the server socket to the desired IP and port.
    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        error_exit("TCP bind failed"); // Exit if bind fails.
    }

    // Put the server socket into listen mode.
    if (listen(server_socket, 5) == -1) {
        error_exit("TCP listen failed"); // Exit if listen fails.
    }

    // Initialize the file descriptor set.
    FD_ZERO(&read_fds);
    FD_SET(server_socket, &read_fds); // Add the server socket to the set.
    max_fd = server_socket; // Initially, the server socket has the highest descriptor number.

    // Record the start time for the duration check.
    time_t start_time = time(NULL);

    // Main loop to handle incoming connections and data forwarding.
    while (1) {
        // Break the loop after the specified duration.
        if (time(NULL) - start_time > args->duration) {
            break;
        }

        // Make a copy of the read_fds set since select alters the set.
        temp_fds = read_fds;

        // Wait until there's an activity on any of the sockets.
        select(max_fd + 1, &temp_fds, NULL, NULL, NULL);

        // Check every socket for activity.
        for (int i = 0; i <= max_fd; i++) {
            if (FD_ISSET(i, &temp_fds)) {
                // If the activity is on the server socket, it's an incoming connection.
                if (i == server_socket) {
                    socklen_t client_len = sizeof(client_addr);

                    // Accept the incoming connection.
                    client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_len);

                    // Create a new socket to connect to the redirection server.
                    redir_socket = socket(AF_INET, SOCK_STREAM, 0);
                    if (redir_socket == -1) {
                        error_exit("Failed to create redirection TCP socket");
                    }

                    // Initialize the redirection server address.
                    memset(&redir_addr, 0, sizeof(redir_addr));
                    redir_addr.sin_family = AF_INET;
                    redir_addr.sin_port = htons(args->redirection_port);
                    inet_pton(AF_INET, args->redirection_ip, &redir_addr.sin_addr);

                    // Connect to the redirection server.
                    if (connect(redir_socket, (struct sockaddr *)&redir_addr, sizeof(redir_addr)) == -1) {
                        error_exit("Failed to connect to redirection server");
                    }

                    // Add the new sockets to the set of descriptors to monitor.
                    FD_SET(client_socket, &read_fds);
                    FD_SET(redir_socket, &read_fds);

                    // Update the max_fd if necessary.
                    if (client_socket > max_fd) {
                        max_fd = client_socket;
                    }
                    if (redir_socket > max_fd) {
                        max_fd = redir_socket;
                    }
                } else {
                    // If the activity is not on the server socket, it's data transfer.
                    ssize_t bytes = recv(i, buffer, sizeof(buffer), 0);
                    if (bytes <= 0) {
                        // If recv returns <= 0, the socket is closed or there's an error.
                        close(i);
                        FD_CLR(i, &read_fds); // Remove the socket from the set.
                    } else {
                        // Forward the received data.
                        if (i == client_socket) {
                            send(redir_socket, buffer, bytes, 0); // From client to redirection server.
                        } else if (i == redir_socket) {
                            send(client_socket, buffer, bytes, 0); // From redirection server to client.
                        }
                    }
                }
            }
        }
    }

    // Close the server socket at the end.
    close(server_socket);
}




void handle_udp(struct RedirectionArgs *args) {
    // Declare a socket descriptor for UDP communication.
    int udp_socket;

    // Declare structures for the server, client, and redirection addresses.
    struct sockaddr_in server_addr, client_addr, redir_addr;

    // Buffer to temporarily store received data.
    char buffer[2048];

    // Declare a variable for the length of the client address. This will be modified by recvfrom().
    socklen_t addr_len = sizeof(client_addr);

    // Create a socket for the server.
    udp_socket = socket(AF_INET, SOCK_DGRAM, 0);
    if (udp_socket == -1) {
        error_exit("Failed to create UDP socket"); // Exit if socket creation fails.
    }

    // Initialize the server address structure to zero.
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET; // Specify the address family (IPv4).
    server_addr.sin_port = htons(args->sending_port); // Set the port number.
    inet_pton(AF_INET, args->sending_ip, &server_addr.sin_addr); // Convert IP address from string to binary form.

    // Bind the server socket to the desired IP and port.
    if (bind(udp_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        error_exit("UDP bind failed"); // Exit if bind fails.
    }

    // Record the start time for the duration check.
    time_t start_time = time(NULL);

    // Main loop to handle incoming packets and data forwarding.
    while (1) {
        // Break the loop after the specified duration.
        if (time(NULL) - start_time > args->duration) {
            break;
        }

        // Receive data from a client. 
        ssize_t bytes = recvfrom(udp_socket, buffer, sizeof(buffer), 0, (struct sockaddr *)&client_addr, &addr_len);
        if (bytes > 0) {
            // If data is successfully received, prepare the redirection address.
            memset(&redir_addr, 0, sizeof(redir_addr));
            redir_addr.sin_family = AF_INET;
            redir_addr.sin_port = htons(args->redirection_port);
            inet_pton(AF_INET, args->redirection_ip, &redir_addr.sin_addr);

            // Send the received data to the redirection address.
            sendto(udp_socket, buffer, bytes, 0, (struct sockaddr *)&redir_addr, sizeof(redir_addr));
        }
    }

    // Close the UDP socket at the end.
    close(udp_socket);
}
