#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <netdb.h>

#define BUFFER_SIZE 4096

// Structure to hold redirection arguments
struct RedirectionArgs {
    int local_port;
    char remote_ip[16];
    int remote_port;
    int duration;
    int is_tcp;
};

// Function to handle errors and exit with a message
void error_exit(const char *message) {
    perror(message);
    exit(1);
}

// Function to create a socket of a specified protocol and socket type
int create_socket(int protocol, int sock_type) {
    int sockfd = socket(AF_INET, sock_type, protocol);
    if (sockfd < 0) error_exit("socket creation failed");
    return sockfd;
}

// Function to create and connect a socket, given a host, port, and socket type
int create_and_connect(char *host, int port, int sock_type) {
    struct addrinfo hints, *res;
    int sockfd;
    char port_str[6];

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = sock_type;

    sprintf(port_str, "%d", port);
    if (getaddrinfo(host, port_str, &hints, &res) != 0)
        error_exit("getaddrinfo failed");

    sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (sockfd < 0)
        error_exit("socket creation failed");

    if (connect(sockfd, res->ai_addr, res->ai_addrlen) < 0)
        error_exit("connect failed");

    freeaddrinfo(res);
    return sockfd;
}

// Function to forward data from the source socket to the destination socket
void forward(int src_sock, int dest_sock) {
    char buffer[BUFFER_SIZE];
    int len = recv(src_sock, buffer, BUFFER_SIZE, 0);
    if (len > 0) {
        send(dest_sock, buffer, len, 0);
    }
}

// Function to run TCP redirection
void run_tcp_redirection(struct RedirectionArgs *args) {
    int local_sock = create_socket(0, SOCK_STREAM);
    int remote_sock = create_and_connect(args->remote_ip, args->remote_port, SOCK_STREAM);

    // If TCP, listen for incoming connections
    listen(local_sock, 5);
    struct sockaddr_in client_addr;
    socklen_t addr_len = sizeof(client_addr);
    int new_local_sock = accept(local_sock, (struct sockaddr*)&client_addr, &addr_len);
    if (new_local_sock < 0)
        error_exit("accept failed");
    close(local_sock);
    local_sock = new_local_sock;

    struct timeval timeout;
    timeout.tv_sec = args->duration;
    timeout.tv_usec = 0;

    fd_set readfds;

    while (1) {
        FD_ZERO(&readfds);
        FD_SET(local_sock, &readfds);
        FD_SET(remote_sock, &readfds);

        int activity = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);
        if (activity < 0) error_exit("select error");
        if (activity == 0) break;

        if (FD_ISSET(local_sock, &readfds)) {
            forward(local_sock, remote_sock);
        }

        if (FD_ISSET(remote_sock, &readfds)) {
            forward(remote_sock, local_sock);
        }
    }

    close(local_sock);
    close(remote_sock);
}

// Function to run UDP redirection
void run_udp_redirection(struct RedirectionArgs *args) {
    int local_sock = create_socket(0, SOCK_DGRAM);
    int remote_sock = create_and_connect(args->remote_ip, args->remote_port, SOCK_DGRAM);

    struct timeval timeout;
    timeout.tv_sec = args->duration;
    timeout.tv_usec = 0;

    fd_set readfds;

    while (1) {
        FD_ZERO(&readfds);
        FD_SET(local_sock, &readfds);
        FD_SET(remote_sock, &readfds);

        int activity = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);
        if (activity < 0) error_exit("select error");
        if (activity == 0) break;

        if (FD_ISSET(local_sock, &readfds)) {
            forward(local_sock, remote_sock);
        }

        if (FD_ISSET(remote_sock, &readfds)) {
            forward(remote_sock, local_sock);
        }
    }

    close(local_sock);
    close(remote_sock);
}

// Function to run redirection based on the specified protocol
void run_redirection(struct RedirectionArgs *args) {
    if (args->is_tcp) {
        run_tcp_redirection(args);
    } else {
        run_udp_redirection(args);
    }
}

int main(int argc, char *argv[]) {
    int opt;
    struct RedirectionArgs args;
    int set_flags = 0; // Bit flags to ensure all needed args are set

    // Parse command-line arguments using getopt
    while ((opt = getopt(argc, argv, "p:l:r:d:t:")) != -1) {
        switch (opt) {
            case 'p': // Protocol
                args.is_tcp = strcmp(optarg, "tcp") == 0 ? 1 : 0;
                set_flags |= 1 << 0;
                break;
            case 'l': // Local port
                args.local_port = atoi(optarg);
                set_flags |= 1 << 1;
                break;
            case 'r': // Remote IP:port
                sscanf(optarg, "%15[^:]:%d", args.remote_ip, &args.remote_port);
                set_flags |= 1 << 2;
                break;
            case 'd': // Duration
                args.duration = atoi(optarg);
                set_flags |= 1 << 3;
                break;
            case 't': // Total number of redirections (will loop the same settings)
                int total = atoi(optarg);
                for (int i = 0; i < total; ++i) {
                    if (set_flags == (1 << 4) - 1) {
                        run_redirection(&args);
                    } else {
                        fprintf(stderr, "Missing or invalid arguments\n");
                        exit(1);
                    }
                }
                return 0;
            default:
                fprintf(stderr, "Usage: %s -p <protocol> -l <local_port> -r <remote_ip:port> -d <duration> -t <total_redirections>\n", argv[0]);
                exit(1);
        }
    }

    if (set_flags == (1 << 4) - 1) {
        run_redirection(&args);
    } else {
        fprintf(stderr, "Missing or invalid arguments\n");
        exit(1);
    }

    return 0;
}
//useage ./program_name -p tcp -l 8080 -r 192.168.1.10:9090 -d 10